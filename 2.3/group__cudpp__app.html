<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>CUDPP: CUDPP Application-Level API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUDPP
   &#160;<span id="projectnumber">2.3</span>
   </div>
   <div id="projectbrief">CUDA Data-Parallel Primitives Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">CUDPP Application-Level API</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__cudpp__hash__data__structures"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__hash__data__structures.html">Hash Table Data Structures and Constants</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cuda_h_t_1_1_cuckoo_hashing_1_1_hash_table.html">CudaHT::CuckooHashing::HashTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic hash table that stores one value for each key.  <a href="class_cuda_h_t_1_1_cuckoo_hashing_1_1_hash_table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Compact Functions</h2></td></tr>
<tr class="memitem:ga040dfdfedb09338ecbb6c154ce164717"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga040dfdfedb09338ecbb6c154ce164717">calculateCompactLaunchParams</a> (const unsigned int numElements, unsigned int &amp;numThreads, unsigned int &amp;numBlocks, unsigned int &amp;numEltsPerBlock)</td></tr>
<tr class="memdesc:ga040dfdfedb09338ecbb6c154ce164717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate launch parameters for <a class="el" href="group__cudpp__app.html#gad20b81b147eeecd6f2978e54a9eb3efb" title="Compact the non-zero elements of an array. ">compactArray()</a>.  <a href="#ga040dfdfedb09338ecbb6c154ce164717">More...</a><br /></td></tr>
<tr class="separator:ga040dfdfedb09338ecbb6c154ce164717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad20b81b147eeecd6f2978e54a9eb3efb"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gad20b81b147eeecd6f2978e54a9eb3efb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gad20b81b147eeecd6f2978e54a9eb3efb">compactArray</a> (T *d_out, size_t *d_numValidElements, const T *d_in, const unsigned int *d_isValid, size_t numElements, const <a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *plan)</td></tr>
<tr class="memdesc:gad20b81b147eeecd6f2978e54a9eb3efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compact the non-zero elements of an array.  <a href="#gad20b81b147eeecd6f2978e54a9eb3efb">More...</a><br /></td></tr>
<tr class="separator:gad20b81b147eeecd6f2978e54a9eb3efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae84f008f74af507fb9da9568ee22bd21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gae84f008f74af507fb9da9568ee22bd21">allocCompactStorage</a> (<a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *plan)</td></tr>
<tr class="memdesc:gae84f008f74af507fb9da9568ee22bd21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate intermediate arrays used by <a class="el" href="group__public_interface.html#gab3fd0152a8e5b1860b1b7b09a3753ae0" title="Given an array d_in and an array of 1/0 flags in deviceValid, returns a compacted array in d_out of c...">cudppCompact()</a>.  <a href="#gae84f008f74af507fb9da9568ee22bd21">More...</a><br /></td></tr>
<tr class="separator:gae84f008f74af507fb9da9568ee22bd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f6b8e696bb6ec4d87d55046041dfb9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga5f6b8e696bb6ec4d87d55046041dfb9e">freeCompactStorage</a> (<a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *plan)</td></tr>
<tr class="memdesc:ga5f6b8e696bb6ec4d87d55046041dfb9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate intermediate storage used by <a class="el" href="group__public_interface.html#gab3fd0152a8e5b1860b1b7b09a3753ae0" title="Given an array d_in and an array of 1/0 flags in deviceValid, returns a compacted array in d_out of c...">cudppCompact()</a>.  <a href="#ga5f6b8e696bb6ec4d87d55046041dfb9e">More...</a><br /></td></tr>
<tr class="separator:ga5f6b8e696bb6ec4d87d55046041dfb9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafccd7f148a985a1ec19b30cf1d00fdbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gafccd7f148a985a1ec19b30cf1d00fdbf">cudppCompactDispatch</a> (void *d_out, size_t *d_numValidElements, const void *d_in, const unsigned int *d_isValid, size_t numElements, const <a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *plan)</td></tr>
<tr class="memdesc:gafccd7f148a985a1ec19b30cf1d00fdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch compactArray for the specified datatype.  <a href="#gafccd7f148a985a1ec19b30cf1d00fdbf">More...</a><br /></td></tr>
<tr class="separator:gafccd7f148a985a1ec19b30cf1d00fdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Compress Functions</h2></td></tr>
<tr class="memitem:ga61b0eeace5a27886e28282faa9bded32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga61b0eeace5a27886e28282faa9bded32">huffmanEncoding</a> (unsigned int *d_hist, unsigned int *d_encodeOffset, unsigned int *d_compressedSize, unsigned int *d_compressed, size_t numElements, const CUDPPCompressPlan *plan)</td></tr>
<tr class="memdesc:ga61b0eeace5a27886e28282faa9bded32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform Huffman encoding.  <a href="#ga61b0eeace5a27886e28282faa9bded32">More...</a><br /></td></tr>
<tr class="separator:ga61b0eeace5a27886e28282faa9bded32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c2ec03d9b49c97625e4295719944484"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga9c2ec03d9b49c97625e4295719944484"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga9c2ec03d9b49c97625e4295719944484">moveToFrontTransform</a> (unsigned char *d_mtfIn, unsigned char *d_mtfOut, size_t numElements, const T *plan)</td></tr>
<tr class="memdesc:ga9c2ec03d9b49c97625e4295719944484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the Move-to-Front Transform (MTF)  <a href="#ga9c2ec03d9b49c97625e4295719944484">More...</a><br /></td></tr>
<tr class="separator:ga9c2ec03d9b49c97625e4295719944484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf315a304a78117955cad6d8c32a8fab"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gadf315a304a78117955cad6d8c32a8fab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gadf315a304a78117955cad6d8c32a8fab">burrowsWheelerTransform</a> (unsigned char *d_uncompressed, int *d_bwtIndex, unsigned char *d_bwtOut, size_t numElements, const T *plan)</td></tr>
<tr class="memdesc:gadf315a304a78117955cad6d8c32a8fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the Burrows-Wheeler Transform (BWT)  <a href="#gadf315a304a78117955cad6d8c32a8fab">More...</a><br /></td></tr>
<tr class="separator:gadf315a304a78117955cad6d8c32a8fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f998ac3907d8e374be63abb26584372"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga1f998ac3907d8e374be63abb26584372">burrowsWheelerTransformWrapper</a> (unsigned char *d_in, int *d_bwtIndex, size_t numElements, const CUDPPCompressPlan *plan)</td></tr>
<tr class="memdesc:ga1f998ac3907d8e374be63abb26584372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for calling the Burrows-Wheeler Transform (BWT).  <a href="#ga1f998ac3907d8e374be63abb26584372">More...</a><br /></td></tr>
<tr class="separator:ga1f998ac3907d8e374be63abb26584372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c20cb730679c44440eb3681d68c2668"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga8c20cb730679c44440eb3681d68c2668">burrowsWheelerTransformWrapper</a> (unsigned char *d_in, int *d_bwtIndex, unsigned char *d_bwtOut, size_t numElements, const <a class="el" href="class_c_u_d_p_p_bwt_plan.html">CUDPPBwtPlan</a> *plan)</td></tr>
<tr class="memdesc:ga8c20cb730679c44440eb3681d68c2668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for calling the Burrows-Wheeler Transform (BWT).  <a href="#ga8c20cb730679c44440eb3681d68c2668">More...</a><br /></td></tr>
<tr class="separator:ga8c20cb730679c44440eb3681d68c2668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4916d0d00fb75590b75d4c4d8a7acf51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga4916d0d00fb75590b75d4c4d8a7acf51">moveToFrontTransformWrapper</a> (size_t numElements, const CUDPPCompressPlan *plan)</td></tr>
<tr class="memdesc:ga4916d0d00fb75590b75d4c4d8a7acf51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for calling the Move-to-Front (MTF) transform.  <a href="#ga4916d0d00fb75590b75d4c4d8a7acf51">More...</a><br /></td></tr>
<tr class="separator:ga4916d0d00fb75590b75d4c4d8a7acf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6798eb8443a725818dab4c06b33f067e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga6798eb8443a725818dab4c06b33f067e">moveToFrontTransformWrapper</a> (unsigned char *d_in, unsigned char *d_mtfOut, size_t numElements, const <a class="el" href="class_c_u_d_p_p_mtf_plan.html">CUDPPMtfPlan</a> *plan)</td></tr>
<tr class="memdesc:ga6798eb8443a725818dab4c06b33f067e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for calling the Move-to-Front (MTF) transform.  <a href="#ga6798eb8443a725818dab4c06b33f067e">More...</a><br /></td></tr>
<tr class="separator:ga6798eb8443a725818dab4c06b33f067e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e3305c8f69237c1ba7c859e4c1c8532"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga6e3305c8f69237c1ba7c859e4c1c8532">allocBwtStorage</a> (<a class="el" href="class_c_u_d_p_p_bwt_plan.html">CUDPPBwtPlan</a> *plan)</td></tr>
<tr class="memdesc:ga6e3305c8f69237c1ba7c859e4c1c8532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate intermediate arrays used by BWT.  <a href="#ga6e3305c8f69237c1ba7c859e4c1c8532">More...</a><br /></td></tr>
<tr class="separator:ga6e3305c8f69237c1ba7c859e4c1c8532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebe506539a6a0c0211ec5b5704a825b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gaebe506539a6a0c0211ec5b5704a825b0">allocMtfStorage</a> (<a class="el" href="class_c_u_d_p_p_mtf_plan.html">CUDPPMtfPlan</a> *plan)</td></tr>
<tr class="memdesc:gaebe506539a6a0c0211ec5b5704a825b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate intermediate arrays used by MTF.  <a href="#gaebe506539a6a0c0211ec5b5704a825b0">More...</a><br /></td></tr>
<tr class="separator:gaebe506539a6a0c0211ec5b5704a825b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e78a1777b62c4ed99d57998b6216bf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga0e78a1777b62c4ed99d57998b6216bf6">allocCompressStorage</a> (CUDPPCompressPlan *plan)</td></tr>
<tr class="memdesc:ga0e78a1777b62c4ed99d57998b6216bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate intermediate arrays used by compression.  <a href="#ga0e78a1777b62c4ed99d57998b6216bf6">More...</a><br /></td></tr>
<tr class="separator:ga0e78a1777b62c4ed99d57998b6216bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b34f7f6c5234a8b9c9a021bac8d6f15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga2b34f7f6c5234a8b9c9a021bac8d6f15">freeCompressStorage</a> (CUDPPCompressPlan *plan)</td></tr>
<tr class="memdesc:ga2b34f7f6c5234a8b9c9a021bac8d6f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate intermediate block arrays in a CUDPPCompressPlan object.  <a href="#ga2b34f7f6c5234a8b9c9a021bac8d6f15">More...</a><br /></td></tr>
<tr class="separator:ga2b34f7f6c5234a8b9c9a021bac8d6f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f0a7bff9b659cab266bb73538ce6521"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga2f0a7bff9b659cab266bb73538ce6521">freeBwtStorage</a> (<a class="el" href="class_c_u_d_p_p_bwt_plan.html">CUDPPBwtPlan</a> *plan)</td></tr>
<tr class="memdesc:ga2f0a7bff9b659cab266bb73538ce6521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate intermediate block arrays in a <a class="el" href="class_c_u_d_p_p_bwt_plan.html" title="Plan class for BWT. ">CUDPPBwtPlan</a> object.  <a href="#ga2f0a7bff9b659cab266bb73538ce6521">More...</a><br /></td></tr>
<tr class="separator:ga2f0a7bff9b659cab266bb73538ce6521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa0d04a5e136c191db6d4089006ebeec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gaaa0d04a5e136c191db6d4089006ebeec">freeMtfStorage</a> (<a class="el" href="class_c_u_d_p_p_mtf_plan.html">CUDPPMtfPlan</a> *plan)</td></tr>
<tr class="memdesc:gaaa0d04a5e136c191db6d4089006ebeec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate intermediate block arrays in a <a class="el" href="class_c_u_d_p_p_mtf_plan.html" title="Plan class for MTF. ">CUDPPMtfPlan</a> object.  <a href="#gaaa0d04a5e136c191db6d4089006ebeec">More...</a><br /></td></tr>
<tr class="separator:gaaa0d04a5e136c191db6d4089006ebeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad14e0a21423bd754bd31d2cedf0cd6c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gad14e0a21423bd754bd31d2cedf0cd6c3">cudppCompressDispatch</a> (void *d_uncompressed, void *d_bwtIndex, void *d_histSize, void *d_hist, void *d_encodeOffset, void *d_compressedSize, void *d_compressed, size_t numElements, const CUDPPCompressPlan *plan)</td></tr>
<tr class="memdesc:gad14e0a21423bd754bd31d2cedf0cd6c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch function to perform parallel compression on an array with the specified configuration.  <a href="#gad14e0a21423bd754bd31d2cedf0cd6c3">More...</a><br /></td></tr>
<tr class="separator:gad14e0a21423bd754bd31d2cedf0cd6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00202ecc11a1b3db90ef20cdfddf998a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga00202ecc11a1b3db90ef20cdfddf998a">cudppBwtDispatch</a> (void *d_in, void *d_out, void *d_index, size_t numElements, const <a class="el" href="class_c_u_d_p_p_bwt_plan.html">CUDPPBwtPlan</a> *plan)</td></tr>
<tr class="memdesc:ga00202ecc11a1b3db90ef20cdfddf998a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch function to perform the Burrows-Wheeler transform.  <a href="#ga00202ecc11a1b3db90ef20cdfddf998a">More...</a><br /></td></tr>
<tr class="separator:ga00202ecc11a1b3db90ef20cdfddf998a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4beae76e9c73c3ea6a00c06de544795e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga4beae76e9c73c3ea6a00c06de544795e">cudppMtfDispatch</a> (void *d_in, void *d_out, size_t numElements, const <a class="el" href="class_c_u_d_p_p_mtf_plan.html">CUDPPMtfPlan</a> *plan)</td></tr>
<tr class="memdesc:ga4beae76e9c73c3ea6a00c06de544795e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch function to perform the Move-to-Front transform.  <a href="#ga4beae76e9c73c3ea6a00c06de544795e">More...</a><br /></td></tr>
<tr class="separator:ga4beae76e9c73c3ea6a00c06de544795e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
ListRank Functions</h2></td></tr>
<tr class="memitem:ga01bedf77673d5b88ff3350b2da6517fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga01bedf77673d5b88ff3350b2da6517fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga01bedf77673d5b88ff3350b2da6517fa">listRank</a> (T *d_ranked_values, T *d_unranked_values, int *d_next_indices, size_t head, size_t numElements, const <a class="el" href="class_c_u_d_p_p_list_rank_plan.html">CUDPPListRankPlan</a> *plan)</td></tr>
<tr class="memdesc:ga01bedf77673d5b88ff3350b2da6517fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch list ranking.  <a href="#ga01bedf77673d5b88ff3350b2da6517fa">More...</a><br /></td></tr>
<tr class="separator:ga01bedf77673d5b88ff3350b2da6517fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga355d6255be4206b598445d017489fbab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga355d6255be4206b598445d017489fbab">allocListRankStorage</a> (<a class="el" href="class_c_u_d_p_p_list_rank_plan.html">CUDPPListRankPlan</a> *plan)</td></tr>
<tr class="memdesc:ga355d6255be4206b598445d017489fbab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate intermediate arrays used by ListRank.  <a href="#ga355d6255be4206b598445d017489fbab">More...</a><br /></td></tr>
<tr class="separator:ga355d6255be4206b598445d017489fbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbe7bfb2886d9a37ec07836e385635d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gacbe7bfb2886d9a37ec07836e385635d5">freeListRankStorage</a> (<a class="el" href="class_c_u_d_p_p_list_rank_plan.html">CUDPPListRankPlan</a> *plan)</td></tr>
<tr class="memdesc:gacbe7bfb2886d9a37ec07836e385635d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate intermediate block arrays in a <a class="el" href="class_c_u_d_p_p_list_rank_plan.html" title="Plan class for ListRank. ">CUDPPListRankPlan</a> object.  <a href="#gacbe7bfb2886d9a37ec07836e385635d5">More...</a><br /></td></tr>
<tr class="separator:gacbe7bfb2886d9a37ec07836e385635d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf384cd261f362eef6a000dc5b15aa53e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gaf384cd261f362eef6a000dc5b15aa53e">cudppListRankDispatch</a> (void *d_ranked_values, void *d_unranked_values, void *d_next_indices, size_t head, size_t numElements, const <a class="el" href="class_c_u_d_p_p_list_rank_plan.html">CUDPPListRankPlan</a> *plan)</td></tr>
<tr class="memdesc:gaf384cd261f362eef6a000dc5b15aa53e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch function to perform parallel list ranking on a linked-list with the specified configuration.  <a href="#gaf384cd261f362eef6a000dc5b15aa53e">More...</a><br /></td></tr>
<tr class="separator:gaf384cd261f362eef6a000dc5b15aa53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
MergeSort Functions</h2></td></tr>
<tr class="memitem:ga925a72eb7e4c7417d0304e9872025218"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga925a72eb7e4c7417d0304e9872025218"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga925a72eb7e4c7417d0304e9872025218">runMergeSort</a> (T *pkeys, unsigned int *pvals, size_t numElements, const <a class="el" href="class_c_u_d_p_p_merge_sort_plan.html">CUDPPMergeSortPlan</a> *plan)</td></tr>
<tr class="memdesc:ga925a72eb7e4c7417d0304e9872025218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs merge sort utilizing 3 stages: (1) Blocksort, (2) simple merge and (3) multi merge.  <a href="#ga925a72eb7e4c7417d0304e9872025218">More...</a><br /></td></tr>
<tr class="separator:ga925a72eb7e4c7417d0304e9872025218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1ad99cc80465972cf1fb732b81ab8e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gad1ad99cc80465972cf1fb732b81ab8e6">allocMergeSortStorage</a> (<a class="el" href="class_c_u_d_p_p_merge_sort_plan.html">CUDPPMergeSortPlan</a> *plan)</td></tr>
<tr class="memdesc:gad1ad99cc80465972cf1fb732b81ab8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">From the programmer-specified sort configuration, creates internal memory for performing the sort.  <a href="#gad1ad99cc80465972cf1fb732b81ab8e6">More...</a><br /></td></tr>
<tr class="separator:gad1ad99cc80465972cf1fb732b81ab8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga290ef022e420d9721f8cb15d1475c074"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga290ef022e420d9721f8cb15d1475c074">freeMergeSortStorage</a> (<a class="el" href="class_c_u_d_p_p_merge_sort_plan.html">CUDPPMergeSortPlan</a> *plan)</td></tr>
<tr class="memdesc:ga290ef022e420d9721f8cb15d1475c074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates intermediate memory from allocRadixSortStorage.  <a href="#ga290ef022e420d9721f8cb15d1475c074">More...</a><br /></td></tr>
<tr class="separator:ga290ef022e420d9721f8cb15d1475c074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cefde64490a053ec2453c0a7897840e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga1cefde64490a053ec2453c0a7897840e">cudppMergeSortDispatch</a> (void *keys, void *values, size_t numElements, const <a class="el" href="class_c_u_d_p_p_merge_sort_plan.html">CUDPPMergeSortPlan</a> *plan)</td></tr>
<tr class="memdesc:ga1cefde64490a053ec2453c0a7897840e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch function to perform a sort on an array with a specified configuration.  <a href="#ga1cefde64490a053ec2453c0a7897840e">More...</a><br /></td></tr>
<tr class="separator:ga1cefde64490a053ec2453c0a7897840e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67cf5220afab3f55dde96a0ee40ace3e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga67cf5220afab3f55dde96a0ee40ace3e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BLOCKSORT_SIZE</b>&#160;&#160;&#160;1024</td></tr>
<tr class="separator:ga67cf5220afab3f55dde96a0ee40ace3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50267d552ca6f788254032e40046b770"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga50267d552ca6f788254032e40046b770"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DEPTH</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:ga50267d552ca6f788254032e40046b770"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
MultiSplit Functions</h2></td></tr>
<tr class="memitem:gae4c0a0fec8f6a16c477cb6b45982ba6a"><td class="memTemplParams" colspan="2"><a class="anchor" id="gae4c0a0fec8f6a16c477cb6b45982ba6a"></a>
template&lt;typename bucket_t , typename key_type &gt; </td></tr>
<tr class="memitem:gae4c0a0fec8f6a16c477cb6b45982ba6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multisplit_WMS_prescan_function</b> (key_type *d_key_in, uint32_t num_elements, bucket_t bucket_identifier, uint32_t num_buckets, uint32_t num_blocks_raw, uint32_t &amp;num_blocks_pre, uint32_t &amp;num_sub_problems, multisplit_context &amp;context)</td></tr>
<tr class="separator:gae4c0a0fec8f6a16c477cb6b45982ba6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9425de009fa5f71c012f68a4240bd79"><td class="memTemplParams" colspan="2"><a class="anchor" id="gad9425de009fa5f71c012f68a4240bd79"></a>
template&lt;typename bucket_t , typename key_type &gt; </td></tr>
<tr class="memitem:gad9425de009fa5f71c012f68a4240bd79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multisplit_WMS_pairs_prescan_function</b> (key_type *d_key_in, uint32_t num_elements, bucket_t bucket_identifier, uint32_t num_buckets, uint32_t num_blocks_raw, uint32_t &amp;num_blocks_pre, uint32_t &amp;num_sub_problems, multisplit_context &amp;context)</td></tr>
<tr class="separator:gad9425de009fa5f71c012f68a4240bd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0755d641aa2264181991451e5d0dd2a6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga0755d641aa2264181991451e5d0dd2a6"></a>
template&lt;typename bucket_t , typename key_type &gt; </td></tr>
<tr class="memitem:ga0755d641aa2264181991451e5d0dd2a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multisplit_WMS_postscan_function</b> (key_type *d_key_in, key_type *d_key_out, uint32_t num_elements, bucket_t bucket_identifier, uint32_t num_buckets, uint32_t num_blocks_post, multisplit_context &amp;context)</td></tr>
<tr class="separator:ga0755d641aa2264181991451e5d0dd2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78a897b049e08e459928a0f0cac7fca3"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga78a897b049e08e459928a0f0cac7fca3"></a>
template&lt;typename bucket_t , typename key_type , typename value_type &gt; </td></tr>
<tr class="memitem:ga78a897b049e08e459928a0f0cac7fca3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multisplit_WMS_pairs_postscan_function</b> (key_type *d_key_in, value_type *d_value_in, key_type *d_key_out, value_type *d_value_out, uint32_t num_elements, bucket_t bucket_identifier, uint32_t num_buckets, uint32_t num_blocks_post, multisplit_context &amp;context)</td></tr>
<tr class="separator:ga78a897b049e08e459928a0f0cac7fca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedcb390880cf7d88354df7f485234930"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaedcb390880cf7d88354df7f485234930"></a>
template&lt;typename bucket_t , typename key_type &gt; </td></tr>
<tr class="memitem:gaedcb390880cf7d88354df7f485234930"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multisplit_BMS_prescan_function</b> (key_type *d_key_in, uint32_t num_elements, bucket_t bucket_identifier, uint32_t num_buckets, uint32_t num_blocks_raw, uint32_t &amp;num_blocks_pre, uint32_t &amp;num_sub_problems, multisplit_context &amp;context)</td></tr>
<tr class="separator:gaedcb390880cf7d88354df7f485234930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga963ada0301c1cd69f51b16393430dc19"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga963ada0301c1cd69f51b16393430dc19"></a>
template&lt;typename bucket_t , typename key_type &gt; </td></tr>
<tr class="memitem:ga963ada0301c1cd69f51b16393430dc19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multisplit_BMS_pairs_prescan_function</b> (key_type *d_key_in, uint32_t num_elements, bucket_t bucket_identifier, uint32_t num_buckets, uint32_t num_blocks_raw, uint32_t &amp;num_blocks_pre, uint32_t &amp;num_sub_problems, multisplit_context &amp;context)</td></tr>
<tr class="separator:ga963ada0301c1cd69f51b16393430dc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7a9000d571b33ac2b303dd0223e7cb0"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf7a9000d571b33ac2b303dd0223e7cb0"></a>
template&lt;typename bucket_t , typename key_type &gt; </td></tr>
<tr class="memitem:gaf7a9000d571b33ac2b303dd0223e7cb0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multisplit_BMS_postscan_function</b> (key_type *d_key_in, key_type *d_key_out, uint32_t num_elements, bucket_t bucket_identifier, uint32_t num_buckets, uint32_t num_blocks_post, multisplit_context &amp;context)</td></tr>
<tr class="separator:gaf7a9000d571b33ac2b303dd0223e7cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54fe6b3bc24754af32e24e033f85f93c"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga54fe6b3bc24754af32e24e033f85f93c"></a>
template&lt;typename bucket_t , typename key_type , typename value_type &gt; </td></tr>
<tr class="memitem:ga54fe6b3bc24754af32e24e033f85f93c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multisplit_BMS_pairs_postscan_function</b> (key_type *d_key_in, value_type *d_value_in, key_type *d_key_out, value_type *d_value_out, uint32_t num_elements, bucket_t bucket_identifier, uint32_t num_buckets, uint32_t num_blocks_post, multisplit_context &amp;context)</td></tr>
<tr class="separator:ga54fe6b3bc24754af32e24e033f85f93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga165f070a0d583512e23bb0f633cfd68b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga165f070a0d583512e23bb0f633cfd68b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>multisplit_allocate_key_only</b> (size_t num_elements, uint32_t num_buckets, multisplit_context &amp;context)</td></tr>
<tr class="separator:ga165f070a0d583512e23bb0f633cfd68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9fcaf00b6e43a18c83a66881f84d34f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac9fcaf00b6e43a18c83a66881f84d34f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>multisplit_allocate_key_value</b> (size_t num_elements, uint32_t num_buckets, multisplit_context &amp;context)</td></tr>
<tr class="separator:gac9fcaf00b6e43a18c83a66881f84d34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada00cc41b7bedcafe8ada5ee0a29cbce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gada00cc41b7bedcafe8ada5ee0a29cbce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>multisplit_release_memory</b> (multisplit_context &amp;context)</td></tr>
<tr class="separator:gada00cc41b7bedcafe8ada5ee0a29cbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe9e54e5981e89eb37ca229b358ef364"><td class="memTemplParams" colspan="2">template&lt;typename key_type , typename bucket_t &gt; </td></tr>
<tr class="memitem:gabe9e54e5981e89eb37ca229b358ef364"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gabe9e54e5981e89eb37ca229b358ef364">multisplit_key_only</a> (key_type *d_key_in, key_type *d_key_out, size_t num_elements, uint32_t num_buckets, multisplit_context &amp;context, bucket_t bucket_identifier, bool in_place, uint32_t *bucket_offsets=NULL)</td></tr>
<tr class="memdesc:gabe9e54e5981e89eb37ca229b358ef364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs multisplit on keys only.  <a href="#gabe9e54e5981e89eb37ca229b358ef364">More...</a><br /></td></tr>
<tr class="separator:gabe9e54e5981e89eb37ca229b358ef364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad00c9b5e0fcf14a2bc5e6a2b95db4cee"><td class="memTemplParams" colspan="2">template&lt;typename key_type , typename value_type , typename bucket_t &gt; </td></tr>
<tr class="memitem:gad00c9b5e0fcf14a2bc5e6a2b95db4cee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gad00c9b5e0fcf14a2bc5e6a2b95db4cee">multisplit_key_value</a> (key_type *d_key_in, value_type *d_value_in, key_type *d_key_out, value_type *d_value_out, size_t num_elements, uint32_t num_buckets, multisplit_context &amp;context, bucket_t bucket_identifier, bool in_place, uint32_t *bucket_offsets=NULL)</td></tr>
<tr class="memdesc:gad00c9b5e0fcf14a2bc5e6a2b95db4cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs multisplit on key-value pairs.  <a href="#gad00c9b5e0fcf14a2bc5e6a2b95db4cee">More...</a><br /></td></tr>
<tr class="separator:gad00c9b5e0fcf14a2bc5e6a2b95db4cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f81f66ce78ea93bcb67bf7c84da6794"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6f81f66ce78ea93bcb67bf7c84da6794"></a>
cub::CachingDeviceAllocator&#160;</td><td class="memItemRight" valign="bottom"><b>g_allocator</b> (true)</td></tr>
<tr class="separator:ga6f81f66ce78ea93bcb67bf7c84da6794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06d2262eaa85864e55a41d2fd928e40a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga06d2262eaa85864e55a41d2fd928e40a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga06d2262eaa85864e55a41d2fd928e40a">reducedBitSortKeysOnly</a> (unsigned int *d_inp, uint numElements, uint numBuckets, T bucketMapper, const <a class="el" href="class_c_u_d_p_p_multi_split_plan.html">CUDPPMultiSplitPlan</a> *plan)</td></tr>
<tr class="memdesc:ga06d2262eaa85864e55a41d2fd928e40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs multisplit on keys only using the reduced-bit sort method.  <a href="#ga06d2262eaa85864e55a41d2fd928e40a">More...</a><br /></td></tr>
<tr class="separator:ga06d2262eaa85864e55a41d2fd928e40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9c4e43f381a68868933cd06a4b1a2fd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gae9c4e43f381a68868933cd06a4b1a2fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gae9c4e43f381a68868933cd06a4b1a2fd">reducedBitSortKeyValue</a> (unsigned int *d_keys, unsigned int *d_values, unsigned int numElements, unsigned int numBuckets, T bucketMapper, const <a class="el" href="class_c_u_d_p_p_multi_split_plan.html">CUDPPMultiSplitPlan</a> *plan)</td></tr>
<tr class="memdesc:gae9c4e43f381a68868933cd06a4b1a2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs multisplit on key-value pairs using a reduced-bit sort.  <a href="#gae9c4e43f381a68868933cd06a4b1a2fd">More...</a><br /></td></tr>
<tr class="separator:gae9c4e43f381a68868933cd06a4b1a2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8798342dd9653776ff1687bbbf76720c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga8798342dd9653776ff1687bbbf76720c">allocMultiSplitStorage</a> (<a class="el" href="class_c_u_d_p_p_multi_split_plan.html">CUDPPMultiSplitPlan</a> *plan)</td></tr>
<tr class="memdesc:ga8798342dd9653776ff1687bbbf76720c"><td class="mdescLeft">&#160;</td><td class="mdescRight">From the programmer-specified multisplit configuration, creates internal memory for performing the multisplit. Different storage amounts are required depending on the number of buckets.  <a href="#ga8798342dd9653776ff1687bbbf76720c">More...</a><br /></td></tr>
<tr class="separator:ga8798342dd9653776ff1687bbbf76720c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75966035d042dd09df5dfa1231b95bb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga75966035d042dd09df5dfa1231b95bb0">freeMultiSplitStorage</a> (<a class="el" href="class_c_u_d_p_p_multi_split_plan.html">CUDPPMultiSplitPlan</a> *plan)</td></tr>
<tr class="memdesc:ga75966035d042dd09df5dfa1231b95bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates intermediate memory from allocMultiSplitStorage.  <a href="#ga75966035d042dd09df5dfa1231b95bb0">More...</a><br /></td></tr>
<tr class="separator:ga75966035d042dd09df5dfa1231b95bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9463637ddddc629a85fde7c5edca5b5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga9463637ddddc629a85fde7c5edca5b5a">cudppMultiSplitDispatch</a> (unsigned int *d_keys, unsigned int *d_values, size_t numElements, size_t numBuckets, BucketMappingFunc bucketMappingFunc, const <a class="el" href="class_c_u_d_p_p_multi_split_plan.html">CUDPPMultiSplitPlan</a> *plan)</td></tr>
<tr class="memdesc:ga9463637ddddc629a85fde7c5edca5b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch function to perform multisplit on an array of elements into a number of buckets.  <a href="#ga9463637ddddc629a85fde7c5edca5b5a">More...</a><br /></td></tr>
<tr class="separator:ga9463637ddddc629a85fde7c5edca5b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga782453a76da88245fd9b1bb7ae30b24b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga782453a76da88245fd9b1bb7ae30b24b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MULTISPLIT_WMS_K_ONE_ROLL</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:ga782453a76da88245fd9b1bb7ae30b24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03a862305d45d34317a942232b51e6d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga03a862305d45d34317a942232b51e6d7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MULTISPLIT_WMS_K_TWO_ROLL</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:ga03a862305d45d34317a942232b51e6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03a493c9266cb453ab66083ed1c0edf5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga03a493c9266cb453ab66083ed1c0edf5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MULTISPLIT_WMS_K_THREE_ROLL</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:ga03a493c9266cb453ab66083ed1c0edf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace8bebde71d1cec6358eec48474fe28d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gace8bebde71d1cec6358eec48474fe28d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MULTISPLIT_WMS_K_FOUR_ROLL</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:gace8bebde71d1cec6358eec48474fe28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cfdaf1f82424496a1e3e25fe03fd373"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9cfdaf1f82424496a1e3e25fe03fd373"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MULTISPLIT_WMS_K_FIVE_ROLL</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga9cfdaf1f82424496a1e3e25fe03fd373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac62895255ae3315bacc3810ac74344d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac62895255ae3315bacc3810ac74344d2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MULTISPLIT_WMS_KV_ONE_ROLL</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:gac62895255ae3315bacc3810ac74344d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc8d8505a9084e9b00db1fc23973c7ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacc8d8505a9084e9b00db1fc23973c7ff"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MULTISPLIT_WMS_KV_TWO_ROLL</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:gacc8d8505a9084e9b00db1fc23973c7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga518742b9fa5c2838575553c76ea219b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga518742b9fa5c2838575553c76ea219b6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MULTISPLIT_WMS_KV_THREE_ROLL</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga518742b9fa5c2838575553c76ea219b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82d1feca879cab5954efe6c3a84fd5e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga82d1feca879cab5954efe6c3a84fd5e8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MULTISPLIT_WMS_KV_FOUR_ROLL</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga82d1feca879cab5954efe6c3a84fd5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5adaa3c0c8bc941761d779d4784795e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5adaa3c0c8bc941761d779d4784795e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MULTISPLIT_WMS_KV_FIVE_ROLL</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga5adaa3c0c8bc941761d779d4784795e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05c0b6e5e0bfc37aab1560876d2b854e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga05c0b6e5e0bfc37aab1560876d2b854e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MULTISPLIT_BMS_K_ONE_ROLL</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:ga05c0b6e5e0bfc37aab1560876d2b854e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab53f6cdab953579eebac59479233217f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab53f6cdab953579eebac59479233217f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MULTISPLIT_BMS_K_TWO_ROLL</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:gab53f6cdab953579eebac59479233217f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a4fff91325fc3bcc11a8e9e5feadeda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4a4fff91325fc3bcc11a8e9e5feadeda"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MULTISPLIT_BMS_K_THREE_ROLL</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:ga4a4fff91325fc3bcc11a8e9e5feadeda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bb0a274e5d2f0ad0ad31387ce7399d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6bb0a274e5d2f0ad0ad31387ce7399d4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MULTISPLIT_BMS_K_FOUR_ROLL</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:ga6bb0a274e5d2f0ad0ad31387ce7399d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa1888a183efd8de252e268ad2afde76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaa1888a183efd8de252e268ad2afde76"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MULTISPLIT_BMS_K_FIVE_ROLL</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:gaaa1888a183efd8de252e268ad2afde76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9b6f771218e572c3aa68010db194122"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac9b6f771218e572c3aa68010db194122"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MULTISPLIT_BMS_KV_ONE_ROLL</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:gac9b6f771218e572c3aa68010db194122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga864c5a6399f14233eeb0f1a7c79ac02f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga864c5a6399f14233eeb0f1a7c79ac02f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MULTISPLIT_BMS_KV_TWO_ROLL</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:ga864c5a6399f14233eeb0f1a7c79ac02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c2193e93d6cc9eac73498a1fc9e49ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8c2193e93d6cc9eac73498a1fc9e49ba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MULTISPLIT_BMS_KV_THREE_ROLL</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga8c2193e93d6cc9eac73498a1fc9e49ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacc7c2c20cab9fbe76f1f9456b5b23bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaacc7c2c20cab9fbe76f1f9456b5b23bc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MULTISPLIT_BMS_KV_FOUR_ROLL</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:gaacc7c2c20cab9fbe76f1f9456b5b23bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga217fb401f61aecdaa1f4f1eaea66f7e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga217fb401f61aecdaa1f4f1eaea66f7e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MULTISPLIT_BMS_KV_FIVE_ROLL</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga217fb401f61aecdaa1f4f1eaea66f7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga910056cd6b327cebbcf302e85d6bb8f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga910056cd6b327cebbcf302e85d6bb8f7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MULTISPLIT_SWITCH_STRATEGY_K</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:ga910056cd6b327cebbcf302e85d6bb8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61ce84e7159b1ecfb52b74a133ca449a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga61ce84e7159b1ecfb52b74a133ca449a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MULTISPLIT_SWITCH_STRATEGY_KV</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:ga61ce84e7159b1ecfb52b74a133ca449a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga268f79d0054b6c15fb34142a441902d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga268f79d0054b6c15fb34142a441902d1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MULTISPLIT_NUM_WARPS</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:ga268f79d0054b6c15fb34142a441902d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65be06b46c68442de42bf99b165e3d37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga65be06b46c68442de42bf99b165e3d37"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MULTISPLIT_LOG_WARPS</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:ga65be06b46c68442de42bf99b165e3d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab49186ab97b557985ddd221fdcdf540f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab49186ab97b557985ddd221fdcdf540f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MULTISPLIT_WARP_WIDTH</b>&#160;&#160;&#160;32</td></tr>
<tr class="separator:gab49186ab97b557985ddd221fdcdf540f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eeef1032f96548347b9bad749f1b78c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9eeef1032f96548347b9bad749f1b78c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MULTISPLIT_TRHEADS_PER_BLOCK</b>&#160;&#160;&#160;(MULTISPLIT_WARP_WIDTH * MULTISPLIT_NUM_WARPS)</td></tr>
<tr class="separator:ga9eeef1032f96548347b9bad749f1b78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
RadixSort Functions</h2></td></tr>
<tr class="memitem:gaa6043ddac717a99c471bb3dc0fc3c0de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gaa6043ddac717a99c471bb3dc0fc3c0de">allocRadixSortStorage</a> (<a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *plan)</td></tr>
<tr class="memdesc:gaa6043ddac717a99c471bb3dc0fc3c0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">From the programmer-specified sort configuration, creates internal memory for performing the sort.  <a href="#gaa6043ddac717a99c471bb3dc0fc3c0de">More...</a><br /></td></tr>
<tr class="separator:gaa6043ddac717a99c471bb3dc0fc3c0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b103658becc8dbb8c5ca1026ff61598"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga5b103658becc8dbb8c5ca1026ff61598">freeRadixSortStorage</a> (<a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *plan)</td></tr>
<tr class="memdesc:ga5b103658becc8dbb8c5ca1026ff61598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates intermediate memory from allocRadixSortStorage.  <a href="#ga5b103658becc8dbb8c5ca1026ff61598">More...</a><br /></td></tr>
<tr class="separator:ga5b103658becc8dbb8c5ca1026ff61598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02ed5f1fa1f82c07f4d3244dc0e46622"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga02ed5f1fa1f82c07f4d3244dc0e46622"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga02ed5f1fa1f82c07f4d3244dc0e46622"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>runSort</b> (T *pkeys, unsigned int *pvals, size_t numElements, const <a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *plan)</td></tr>
<tr class="separator:ga02ed5f1fa1f82c07f4d3244dc0e46622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75c1c0e157a23d4747fc2ae94570aab0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga75c1c0e157a23d4747fc2ae94570aab0">cudppRadixSortDispatch</a> (void *keys, void *values, size_t numElements, const <a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *plan)</td></tr>
<tr class="memdesc:ga75c1c0e157a23d4747fc2ae94570aab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch function to perform a sort on an array with a specified configuration.  <a href="#ga75c1c0e157a23d4747fc2ae94570aab0">More...</a><br /></td></tr>
<tr class="separator:ga75c1c0e157a23d4747fc2ae94570aab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Suffix Array Functions</h2></td></tr>
<tr class="memitem:gaf341dae6c968df2f279c2fad825260b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gaf341dae6c968df2f279c2fad825260b4">KeyValueSort</a> (unsigned int num_elements, unsigned int *d_keys, unsigned int *d_values)</td></tr>
<tr class="memdesc:gaf341dae6c968df2f279c2fad825260b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radix Sort kernel from NVlab cub library.  <a href="#gaf341dae6c968df2f279c2fad825260b4">More...</a><br /></td></tr>
<tr class="separator:gaf341dae6c968df2f279c2fad825260b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa21194947434a2c765a167a466dfe71a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gaa21194947434a2c765a167a466dfe71a">ComputeSA</a> (unsigned int *d_str, unsigned int *d_keys_sa, size_t str_length, mgpu::CudaContext &amp;context, <a class="el" href="class_c_u_d_p_p_sa_plan.html">CUDPPSaPlan</a> *plan, unsigned int offset, unsigned int stage)</td></tr>
<tr class="memdesc:gaa21194947434a2c765a167a466dfe71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform Suffix Array (SA) using skew algorithm.  <a href="#gaa21194947434a2c765a167a466dfe71a">More...</a><br /></td></tr>
<tr class="separator:gaa21194947434a2c765a167a466dfe71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea92f85528a823aa09cee9a837f25257"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gaea92f85528a823aa09cee9a837f25257">allocSaStorage</a> (<a class="el" href="class_c_u_d_p_p_sa_plan.html">CUDPPSaPlan</a> *plan)</td></tr>
<tr class="memdesc:gaea92f85528a823aa09cee9a837f25257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate intermediate arrays used by suffix array.  <a href="#gaea92f85528a823aa09cee9a837f25257">More...</a><br /></td></tr>
<tr class="separator:gaea92f85528a823aa09cee9a837f25257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70c30e805f5f2df3c3d3972277b6bdd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga70c30e805f5f2df3c3d3972277b6bdd0">freeSaStorage</a> (<a class="el" href="class_c_u_d_p_p_sa_plan.html">CUDPPSaPlan</a> *plan)</td></tr>
<tr class="memdesc:ga70c30e805f5f2df3c3d3972277b6bdd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate intermediate block arrays in a <a class="el" href="class_c_u_d_p_p_sa_plan.html" title="Plan class for suffix array. ">CUDPPSaPlan</a> object.  <a href="#ga70c30e805f5f2df3c3d3972277b6bdd0">More...</a><br /></td></tr>
<tr class="separator:ga70c30e805f5f2df3c3d3972277b6bdd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d03d94fc60e03cbf736caf6edb0f3ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga0d03d94fc60e03cbf736caf6edb0f3ee">cudppSuffixArrayDispatch</a> (void *d_str, unsigned int *d_keys_sa, size_t d_str_length, <a class="el" href="class_c_u_d_p_p_sa_plan.html">CUDPPSaPlan</a> *plan)</td></tr>
<tr class="memdesc:ga0d03d94fc60e03cbf736caf6edb0f3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch function to perform parallel suffix array on a string with the specified configuration.  <a href="#ga0d03d94fc60e03cbf736caf6edb0f3ee">More...</a><br /></td></tr>
<tr class="separator:ga0d03d94fc60e03cbf736caf6edb0f3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Scan Functions</h2></td></tr>
<tr class="memitem:ga1642453a15896f873da0e378471ea809"><td class="memTemplParams" colspan="2">template&lt;class T , bool isBackward, bool isExclusive, class Op &gt; </td></tr>
<tr class="memitem:ga1642453a15896f873da0e378471ea809"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga1642453a15896f873da0e378471ea809">scanArrayRecursive</a> (T *d_out, const T *d_in, T **d_blockSums, size_t numElements, size_t numRows, const size_t *rowPitches, int level)</td></tr>
<tr class="memdesc:ga1642453a15896f873da0e378471ea809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform recursive scan on arbitrary size arrays.  <a href="#ga1642453a15896f873da0e378471ea809">More...</a><br /></td></tr>
<tr class="separator:ga1642453a15896f873da0e378471ea809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga344e15dee4b3b2351c40bd9cc732bed6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6">allocScanStorage</a> (<a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *plan)</td></tr>
<tr class="memdesc:ga344e15dee4b3b2351c40bd9cc732bed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate intermediate arrays used by scan.  <a href="#ga344e15dee4b3b2351c40bd9cc732bed6">More...</a><br /></td></tr>
<tr class="separator:ga344e15dee4b3b2351c40bd9cc732bed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga399f5095b183ad026687fd227802ba5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga399f5095b183ad026687fd227802ba5c">freeScanStorage</a> (<a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *plan)</td></tr>
<tr class="memdesc:ga399f5095b183ad026687fd227802ba5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate intermediate block sums arrays in a <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm. ">CUDPPScanPlan</a> object.  <a href="#ga399f5095b183ad026687fd227802ba5c">More...</a><br /></td></tr>
<tr class="separator:ga399f5095b183ad026687fd227802ba5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace2b5676a8fad512ba9cf7234870dc0e"><td class="memTemplParams" colspan="2"><a class="anchor" id="gace2b5676a8fad512ba9cf7234870dc0e"></a>
template&lt;typename T , bool isBackward, bool isExclusive&gt; </td></tr>
<tr class="memitem:gace2b5676a8fad512ba9cf7234870dc0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cudppScanDispatchOperator</b> (void *d_out, const void *d_in, size_t numElements, size_t numRows, const <a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *plan)</td></tr>
<tr class="separator:gace2b5676a8fad512ba9cf7234870dc0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0edd85ff4704aac61d9177ed54482e0"><td class="memTemplParams" colspan="2"><a class="anchor" id="gac0edd85ff4704aac61d9177ed54482e0"></a>
template&lt;bool isBackward, bool isExclusive&gt; </td></tr>
<tr class="memitem:gac0edd85ff4704aac61d9177ed54482e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cudppScanDispatchType</b> (void *d_out, const void *d_in, size_t numElements, size_t numRows, const <a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *plan)</td></tr>
<tr class="separator:gac0edd85ff4704aac61d9177ed54482e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49485cb95e21695293a9c35f8355336d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga49485cb95e21695293a9c35f8355336d">cudppScanDispatch</a> (void *d_out, const void *d_in, size_t numElements, size_t numRows, const <a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *plan)</td></tr>
<tr class="memdesc:ga49485cb95e21695293a9c35f8355336d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch function to perform a scan (prefix sum) on an array with the specified configuration.  <a href="#ga49485cb95e21695293a9c35f8355336d">More...</a><br /></td></tr>
<tr class="separator:ga49485cb95e21695293a9c35f8355336d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
StringSort Functions</h2></td></tr>
<tr class="memitem:gae8f803b69e09bdb0a29176e32a0d1759"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae8f803b69e09bdb0a29176e32a0d1759"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dotAdd</b> (unsigned int *d_address, unsigned int *numSpaces, unsigned int *packedAddress, size_t numElements, size_t stringArrayLength)</td></tr>
<tr class="separator:gae8f803b69e09bdb0a29176e32a0d1759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd07b8adcd5479bb49bd49e7d2ea07b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadd07b8adcd5479bb49bd49e7d2ea07b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>calculateAlignedOffsets</b> (unsigned int *d_address, unsigned int *numSpaces, unsigned char *d_stringVals, unsigned char termC, size_t numElements, size_t stringArrayLength)</td></tr>
<tr class="separator:gadd07b8adcd5479bb49bd49e7d2ea07b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfacdceda39eb467ebd56d564e3442d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabfacdceda39eb467ebd56d564e3442d8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>packStrings</b> (unsigned int *packedStrings, unsigned char *d_stringVals, unsigned int *d_keys, unsigned int *packedAddress, unsigned int *address, size_t numElements, size_t stringArrayLength, unsigned char termC)</td></tr>
<tr class="separator:gabfacdceda39eb467ebd56d564e3442d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33305fcb11eb38f4732e23f14177fbc7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga33305fcb11eb38f4732e23f14177fbc7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unpackStrings</b> (unsigned int *packedAddress, unsigned int *packedAddressRef, unsigned int *address, unsigned int *addressRef, size_t numElements)</td></tr>
<tr class="separator:ga33305fcb11eb38f4732e23f14177fbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga810cdb458f43cab2fcd22a4e59da2354"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga810cdb458f43cab2fcd22a4e59da2354">runStringSort</a> (unsigned int *pkeys, unsigned int *pvals, unsigned int *stringVals, size_t numElements, size_t stringArrayLength, unsigned char termC, const <a class="el" href="class_c_u_d_p_p_string_sort_plan.html">CUDPPStringSortPlan</a> *plan)</td></tr>
<tr class="memdesc:ga810cdb458f43cab2fcd22a4e59da2354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs merge sor utilzing three stages. (1) Blocksort, (2) simple merge and (3) multi merge on a set of strings.  <a href="#ga810cdb458f43cab2fcd22a4e59da2354">More...</a><br /></td></tr>
<tr class="separator:ga810cdb458f43cab2fcd22a4e59da2354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe53de69a1cdb089b31247af9d0211a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gabe53de69a1cdb089b31247af9d0211a2">allocStringSortStorage</a> (<a class="el" href="class_c_u_d_p_p_string_sort_plan.html">CUDPPStringSortPlan</a> *plan)</td></tr>
<tr class="memdesc:gabe53de69a1cdb089b31247af9d0211a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">From the programmer-specified sort configuration, creates internal memory for performing the sort.  <a href="#gabe53de69a1cdb089b31247af9d0211a2">More...</a><br /></td></tr>
<tr class="separator:gabe53de69a1cdb089b31247af9d0211a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9270888514859ed9d40a3fc310521cbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga9270888514859ed9d40a3fc310521cbd">freeStringSortStorage</a> (<a class="el" href="class_c_u_d_p_p_string_sort_plan.html">CUDPPStringSortPlan</a> *plan)</td></tr>
<tr class="memdesc:ga9270888514859ed9d40a3fc310521cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates intermediate memory from allocStringSortStorage.  <a href="#ga9270888514859ed9d40a3fc310521cbd">More...</a><br /></td></tr>
<tr class="separator:ga9270888514859ed9d40a3fc310521cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25da6df4c589fcc60584ed619118984d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga25da6df4c589fcc60584ed619118984d">cudppStringSortDispatch</a> (unsigned int *keys, unsigned int *values, unsigned int *stringVals, size_t numElements, size_t stringArrayLength, unsigned char termC, const <a class="el" href="class_c_u_d_p_p_string_sort_plan.html">CUDPPStringSortPlan</a> *plan)</td></tr>
<tr class="memdesc:ga25da6df4c589fcc60584ed619118984d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch function to perform a sort on an array with a specified configuration.  <a href="#ga25da6df4c589fcc60584ed619118984d">More...</a><br /></td></tr>
<tr class="separator:ga25da6df4c589fcc60584ed619118984d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67cf5220afab3f55dde96a0ee40ace3e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga67cf5220afab3f55dde96a0ee40ace3e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BLOCKSORT_SIZE</b>&#160;&#160;&#160;1024</td></tr>
<tr class="separator:ga67cf5220afab3f55dde96a0ee40ace3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50267d552ca6f788254032e40046b770"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga50267d552ca6f788254032e40046b770"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DEPTH</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:ga50267d552ca6f788254032e40046b770"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Tridiagonal functions</h2></td></tr>
<tr class="memitem:ga1658b24e498cccaff07d098a13dfa3af"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1658b24e498cccaff07d098a13dfa3af"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1658b24e498cccaff07d098a13dfa3af"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>crpcrSharedSize</b> (unsigned int systemSizeOriginal)</td></tr>
<tr class="separator:ga1658b24e498cccaff07d098a13dfa3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae845df54c4ceb644b405f45e52f5cc17"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae845df54c4ceb644b405f45e52f5cc17"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gae845df54c4ceb644b405f45e52f5cc17">crpcr</a> (T *d_a, T *d_b, T *d_c, T *d_d, T *d_x, unsigned int systemSizeOriginal, unsigned int numSystems)</td></tr>
<tr class="memdesc:gae845df54c4ceb644b405f45e52f5cc17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hybrid CR-PCR solver (CRPCR)  <a href="#gae845df54c4ceb644b405f45e52f5cc17">More...</a><br /></td></tr>
<tr class="separator:gae845df54c4ceb644b405f45e52f5cc17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0509ed92fe9640a9d7ea1ce9cfa639d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga0509ed92fe9640a9d7ea1ce9cfa639d3">cudppTridiagonalDispatch</a> (void *d_a, void *d_b, void *d_c, void *d_d, void *d_x, int systemSize, int numSystems, const <a class="el" href="class_c_u_d_p_p_tridiagonal_plan.html">CUDPPTridiagonalPlan</a> *plan)</td></tr>
<tr class="memdesc:ga0509ed92fe9640a9d7ea1ce9cfa639d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches the tridiagonal function based on the plan.  <a href="#ga0509ed92fe9640a9d7ea1ce9cfa639d3">More...</a><br /></td></tr>
<tr class="separator:ga0509ed92fe9640a9d7ea1ce9cfa639d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The CUDPP Application-Level API contains functions that run on the host CPU and invoke GPU routines in the CUDPP <a class="el" href="group__cudpp__kernel.html">Kernel-Level API</a>. Application-Level API functions are used by CUDPP <a class="el" href="group__public_interface.html">Public Interface</a> functions to implement CUDPP's core functionality. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga040dfdfedb09338ecbb6c154ce164717"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calculateCompactLaunchParams </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>numThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>numBlocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>numEltsPerBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate launch parameters for <a class="el" href="group__cudpp__app.html#gad20b81b147eeecd6f2978e54a9eb3efb" title="Compact the non-zero elements of an array. ">compactArray()</a>. </p>
<p>Calculates the block size and number of blocks from the total number of elements and the maximum threads per block. Called by <a class="el" href="group__cudpp__app.html#gad20b81b147eeecd6f2978e54a9eb3efb" title="Compact the non-zero elements of an array. ">compactArray()</a>.</p>
<p>The calculation is pretty straightforward - the number of blocks is calculated by dividing the number of input elements by the product of the number of threads in each CTA and the number of elements each thread will process. numThreads and numEltsPerBlock are also simple to calculate. Please note that in cases where numElements is not an exact multiple of SCAN_ELTS_PER_THREAD * CTA_SIZE we would have threads which do nothing or have a thread which will process less than SCAN_ELTS_PER_THREAD elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements to sort </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numThreads</td><td>Number of threads in each block </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numBlocks</td><td>Number of blocks </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numEltsPerBlock</td><td>Number of elements processed per block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad20b81b147eeecd6f2978e54a9eb3efb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void compactArray </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>d_numValidElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_isValid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compact the non-zero elements of an array. </p>
<p>Given an input array <em>d_in</em>, <a class="el" href="group__cudpp__app.html#gad20b81b147eeecd6f2978e54a9eb3efb" title="Compact the non-zero elements of an array. ">compactArray()</a> outputs a compacted version which does not have null (zero) elements. Also ouputs the number of non-zero elements in the compacted array. Called by <a class="el" href="group__cudpp__app.html#gafccd7f148a985a1ec19b30cf1d00fdbf" title="Dispatch compactArray for the specified datatype. ">cudppCompactDispatch()</a>.</p>
<p>The algorithm is straightforward, involving two steps (most of the complexity is hidden in scan, invoked with <a class="el" href="group__cudpp__app.html#ga49485cb95e21695293a9c35f8355336d" title="Dispatch function to perform a scan (prefix sum) on an array with the specified configuration. ">cudppScanDispatch()</a> ).</p>
<ol type="1">
<li>scanArray() performs a prefix sum on <em>d_isValid</em> to compute output indices.</li>
<li><a class="el" href="group__cudpp__kernel.html#ga8bcff086bdbdc841344ac99fb7b15e97" title="Consolidate non-null elements - for each non-null element in d_in write it to d_out, in the position specified by d_isValid. Called by compactArray(). ">compactData()</a> takes <em>d_in</em> and an intermediate array of output indices as input and writes the values with valid flags in <em>d_isValid</em> into <em>d_out</em> using the output indices.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>Array of compacted non-null elements </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_numValidElements</td><td>Pointer to unsigned int to store number of non-null elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>Input array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_isValid</td><td>Array of flags, 1 for each non-null element, 0 for each null element. Same length as <em>d_in</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to the plan object used for this compact </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae84f008f74af507fb9da9568ee22bd21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocCompactStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate intermediate arrays used by <a class="el" href="group__public_interface.html#gab3fd0152a8e5b1860b1b7b09a3753ae0" title="Given an array d_in and an array of 1/0 flags in deviceValid, returns a compacted array in d_out of c...">cudppCompact()</a>. </p>
<p>In addition to the internal <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm. ">CUDPPScanPlan</a> contained in <a class="el" href="class_c_u_d_p_p_compact_plan.html" title="Plan class for compact algorithm. ">CUDPPCompactPlan</a>, CUDPPCompact also needs a temporary device array of output indices, which is allocated by this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_compact_plan.html" title="Plan class for compact algorithm. ">CUDPPCompactPlan</a> object within which intermediate storage is allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5f6b8e696bb6ec4d87d55046041dfb9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeCompactStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate intermediate storage used by <a class="el" href="group__public_interface.html#gab3fd0152a8e5b1860b1b7b09a3753ae0" title="Given an array d_in and an array of 1/0 flags in deviceValid, returns a compacted array in d_out of c...">cudppCompact()</a>. </p>
<p>Deallocates the output indices array allocated by <a class="el" href="group__cudpp__app.html#gae84f008f74af507fb9da9568ee22bd21" title="Allocate intermediate arrays used by cudppCompact(). ">allocCompactStorage()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_compact_plan.html" title="Plan class for compact algorithm. ">CUDPPCompactPlan</a> object initialized by <a class="el" href="group__cudpp__app.html#gae84f008f74af507fb9da9568ee22bd21" title="Allocate intermediate arrays used by cudppCompact(). ">allocCompactStorage()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafccd7f148a985a1ec19b30cf1d00fdbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppCompactDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>d_numValidElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_isValid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch compactArray for the specified datatype. </p>
<p>A thin wrapper on top of compactArray which calls <a class="el" href="group__cudpp__app.html#gad20b81b147eeecd6f2978e54a9eb3efb" title="Compact the non-zero elements of an array. ">compactArray()</a> for the data type specified in <em>config</em>. This is the app-level interface to compact used by <a class="el" href="group__public_interface.html#gab3fd0152a8e5b1860b1b7b09a3753ae0" title="Given an array d_in and an array of 1/0 flags in deviceValid, returns a compacted array in d_out of c...">cudppCompact()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>Compacted array of non-zero elements </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_numValidElements</td><td>Pointer to an unsigned int to store the number of non-zero elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>Input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_isValid</td><td>Array of boolean valid flags with same length as <em>d_in</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements to compact </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to plan object for this compact </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga61b0eeace5a27886e28282faa9bded32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void huffmanEncoding </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_encodeOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_compressedSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_compressed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CUDPPCompressPlan *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform Huffman encoding. </p>
<p>Performs Huffman encoding on the input data stream. The input data stream is the output data stream from the previous stage (MTF) in our compress stream.</p>
<p>The input is given by the output of the Move-to-Front transform (MTF). There are a few things that need to be store along with the compressed data. We also store the word offset of the compressed data stream because our data is compressed into indepedent blocks (word granularity) so that they can be encoded and decoded in parallel. The number of independent blocks is HUFF_THREADS_PER_BLOCK*HUFF_WORK_PER_THREAD.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_hist</td><td>Histogram array of the input data stream used for decoding. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_encodeOffset</td><td>An array of the word offsets of the independent compressed data blocks. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_compressedSize</td><td>Pointer to the total size in words of all compressed data blocks combined. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_compressed</td><td>A pointer to the compressed data blocks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of input elements to compress. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to the plan object used for this compress. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9c2ec03d9b49c97625e4295719944484"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void moveToFrontTransform </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_mtfIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_mtfOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the Move-to-Front Transform (MTF) </p>
<p>Performs a Move-to-Front (MTF) transform on the input data stream. The MTF transform is the second stage in our compress pipeline. The MTF manipulates the input data stream to improve the performance of entropy encoding.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_mtfIn</td><td>An array of the input data stream to perform the MTF transform on. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_mtfOut</td><td>An array to store the output of the MTF transform. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of input elements of the MTF transform. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to the plan object used for this MTF transform. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadf315a304a78117955cad6d8c32a8fab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void burrowsWheelerTransform </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_uncompressed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>d_bwtIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_bwtOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the Burrows-Wheeler Transform (BWT) </p>
<p>Performs the Burrows-Wheeler Transform (BWT) on a given character string. The BWT is an algorithm which is commonly used in compression applications, mainly bzip2. The BWT orders the characters in such a way that the output tends to have many long runs of repeated characters. This bodes well for later stages in compression pipelines which perform better with repeated characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_uncompressed</td><td>A char array of the input data stream to perform the BWT on. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_bwtIndex</td><td>The index at which the original string in the BWT sorts to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_bwtOut</td><td>An array to store the output of the BWT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of input elements of the BWT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to the plan object used for this BWT. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1f998ac3907d8e374be63abb26584372"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void burrowsWheelerTransformWrapper </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>d_bwtIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CUDPPCompressPlan *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for calling the Burrows-Wheeler Transform (BWT). </p>
<p>This is a wrapper function for calling the BWT. This wrapper is used internally via the compress application to call <a class="el" href="group__cudpp__app.html#gadf315a304a78117955cad6d8c32a8fab" title="Perform the Burrows-Wheeler Transform (BWT) ">burrowsWheelerTransform()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>A char array of the input data stream to perform the BWT on. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_bwtIndex</td><td>The index at which the original string in the BWT sorts to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of input elements to the compress stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to the plan object used for this compress. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8c20cb730679c44440eb3681d68c2668"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void burrowsWheelerTransformWrapper </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>d_bwtIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_bwtOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_bwt_plan.html">CUDPPBwtPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for calling the Burrows-Wheeler Transform (BWT). </p>
<p>This is a wrapper function for calling the BWT. This wrapper is used internally via the BWT primitive to call <a class="el" href="group__cudpp__app.html#gadf315a304a78117955cad6d8c32a8fab" title="Perform the Burrows-Wheeler Transform (BWT) ">burrowsWheelerTransform()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>A char array of the input data stream to perform the BWT on. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_bwtIndex</td><td>The index at which the original string in the BWT sorts to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_bwtOut</td><td>An array to store the output of the BWT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of input elements to the BWT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to the plan object used for this BWT. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4916d0d00fb75590b75d4c4d8a7acf51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void moveToFrontTransformWrapper </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CUDPPCompressPlan *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for calling the Move-to-Front (MTF) transform. </p>
<p>This is a wrapper function for calling the MTF. This wrapper is used internally via the compress application to call <a class="el" href="group__cudpp__app.html#ga9c2ec03d9b49c97625e4295719944484" title="Perform the Move-to-Front Transform (MTF) ">moveToFrontTransform()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of input elements to the MTF transform. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to the plan object used for this compress. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6798eb8443a725818dab4c06b33f067e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void moveToFrontTransformWrapper </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_mtfOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_mtf_plan.html">CUDPPMtfPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for calling the Move-to-Front (MTF) transform. </p>
<p>This is a wrapper function for calling the MTF. This wrapper is used internally via the MTF primitive to call <a class="el" href="group__cudpp__app.html#ga9c2ec03d9b49c97625e4295719944484" title="Perform the Move-to-Front Transform (MTF) ">moveToFrontTransform()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>An input char array to perform the MTF on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_mtfOut</td><td>An output char array to store the MTF transformed stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of input elements to the MTF transform. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to the plan object used for this MTF. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6e3305c8f69237c1ba7c859e4c1c8532"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocBwtStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_bwt_plan.html">CUDPPBwtPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate intermediate arrays used by BWT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_bwt_plan.html" title="Plan class for BWT. ">CUDPPBwtPlan</a> object containing options and number of elements, which is used to compute storage requirements, and within which intermediate storage is allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaebe506539a6a0c0211ec5b5704a825b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocMtfStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_mtf_plan.html">CUDPPMtfPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate intermediate arrays used by MTF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_mtf_plan.html" title="Plan class for MTF. ">CUDPPMtfPlan</a> object containing options and number of elements, which is used to compute storage requirements, and within which intermediate storage is allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0e78a1777b62c4ed99d57998b6216bf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocCompressStorage </td>
          <td>(</td>
          <td class="paramtype">CUDPPCompressPlan *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate intermediate arrays used by compression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">plan</td><td>Pointer to CUDPPCompressPlan object containing options and number of elements, which is used to compute storage requirements, and within which intermediate storage is allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2b34f7f6c5234a8b9c9a021bac8d6f15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeCompressStorage </td>
          <td>(</td>
          <td class="paramtype">CUDPPCompressPlan *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate intermediate block arrays in a CUDPPCompressPlan object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">plan</td><td>Pointer to CUDPPCompressPlan object initialized by <a class="el" href="group__cudpp__app.html#ga0e78a1777b62c4ed99d57998b6216bf6" title="Allocate intermediate arrays used by compression. ">allocCompressStorage()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2f0a7bff9b659cab266bb73538ce6521"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeBwtStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_bwt_plan.html">CUDPPBwtPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate intermediate block arrays in a <a class="el" href="class_c_u_d_p_p_bwt_plan.html" title="Plan class for BWT. ">CUDPPBwtPlan</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_bwt_plan.html" title="Plan class for BWT. ">CUDPPBwtPlan</a> object initialized by <a class="el" href="group__cudpp__app.html#ga6e3305c8f69237c1ba7c859e4c1c8532" title="Allocate intermediate arrays used by BWT. ">allocBwtStorage()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaa0d04a5e136c191db6d4089006ebeec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeMtfStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_mtf_plan.html">CUDPPMtfPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate intermediate block arrays in a <a class="el" href="class_c_u_d_p_p_mtf_plan.html" title="Plan class for MTF. ">CUDPPMtfPlan</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_mtf_plan.html" title="Plan class for MTF. ">CUDPPMtfPlan</a> object initialized by <a class="el" href="group__cudpp__app.html#gaebe506539a6a0c0211ec5b5704a825b0" title="Allocate intermediate arrays used by MTF. ">allocMtfStorage()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad14e0a21423bd754bd31d2cedf0cd6c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppCompressDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_uncompressed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_bwtIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_histSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_encodeOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_compressedSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_compressed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CUDPPCompressPlan *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch function to perform parallel compression on an array with the specified configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_uncompressed</td><td>Uncompressed data </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_bwtIndex</td><td>BWT Index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_histSize</td><td>Histogram size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_hist</td><td>Histogram </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_encodeOffset</td><td>Encoded offset table </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_compressedSize</td><td>Size of compressed data </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_compressed</td><td>Compressed data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements to compress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to CUDPPCompressPlan object containing compress options and intermediate storage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga00202ecc11a1b3db90ef20cdfddf998a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppBwtDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_bwt_plan.html">CUDPPBwtPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch function to perform the Burrows-Wheeler transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>Input data </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>Transformed data </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_index</td><td>BWT Index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements to compress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_bwt_plan.html" title="Plan class for BWT. ">CUDPPBwtPlan</a> object containing compress options and intermediate storage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4beae76e9c73c3ea6a00c06de544795e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppMtfDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_mtf_plan.html">CUDPPMtfPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch function to perform the Move-to-Front transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>Input data </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>Transformed data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements to compress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_mtf_plan.html" title="Plan class for MTF. ">CUDPPMtfPlan</a> object containing compress options and intermediate storage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga01bedf77673d5b88ff3350b2da6517fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void listRank </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_ranked_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_unranked_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>d_next_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_list_rank_plan.html">CUDPPListRankPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Launch list ranking. </p>
<p>Given two inputs arrays, <em>d_unranked_values</em> and <em>d_next_indices</em>, <a class="el" href="group__cudpp__app.html#ga01bedf77673d5b88ff3350b2da6517fa" title="Launch list ranking. ">listRank()</a> outputs a ranked version of the unranked values by traversing the next indices. The head index is <em>head</em>. Called by <a class="el" href="group__cudpp__app.html#gaf384cd261f362eef6a000dc5b15aa53e" title="Dispatch function to perform parallel list ranking on a linked-list with the specified configuration...">cudppListRankDispatch()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_ranked_values</td><td>Ranked values array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_unranked_values</td><td>Unranked values array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_next_indices</td><td>Next indices array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">head</td><td>Head pointer index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of nodes values to rank </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_list_rank_plan.html" title="Plan class for ListRank. ">CUDPPListRankPlan</a> object containing list ranking options and intermediate storage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga355d6255be4206b598445d017489fbab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocListRankStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_list_rank_plan.html">CUDPPListRankPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate intermediate arrays used by ListRank. </p>
<p>CUDPPListRank needs temporary device arrays to store next indices so that it does not overwrite the original array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_list_rank_plan.html" title="Plan class for ListRank. ">CUDPPListRankPlan</a> object containing options and number of elements, which is used to compute storage requirements, and within which intermediate storage is allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacbe7bfb2886d9a37ec07836e385635d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeListRankStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_list_rank_plan.html">CUDPPListRankPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate intermediate block arrays in a <a class="el" href="class_c_u_d_p_p_list_rank_plan.html" title="Plan class for ListRank. ">CUDPPListRankPlan</a> object. </p>
<p>Deallocates the output indices array allocated by <a class="el" href="group__cudpp__app.html#ga355d6255be4206b598445d017489fbab" title="Allocate intermediate arrays used by ListRank. ">allocListRankStorage()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_list_rank_plan.html" title="Plan class for ListRank. ">CUDPPListRankPlan</a> object initialized by <a class="el" href="group__cudpp__app.html#ga355d6255be4206b598445d017489fbab" title="Allocate intermediate arrays used by ListRank. ">allocListRankStorage()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf384cd261f362eef6a000dc5b15aa53e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppListRankDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_ranked_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_unranked_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_next_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_list_rank_plan.html">CUDPPListRankPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch function to perform parallel list ranking on a linked-list with the specified configuration. </p>
<p>A wrapper on top of listRank which calls <a class="el" href="group__cudpp__app.html#ga01bedf77673d5b88ff3350b2da6517fa" title="Launch list ranking. ">listRank()</a> for the data type specified in <em>config</em>. This is the app-level interface to list ranking used by <a class="el" href="group__public_interface.html#ga66d4b12b41fb30088353a8091c51f85a" title="Performs list ranking of linked list node values. ">cudppListRank()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_ranked_values</td><td>Ranked values array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_unranked_values</td><td>Unranked values array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_next_indices</td><td>Next indices array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">head</td><td>Head pointer index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of nodes values to rank </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_list_rank_plan.html" title="Plan class for ListRank. ">CUDPPListRankPlan</a> object containing list ranking options and intermediate storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition </dd></dl>

</div>
</div>
<a class="anchor" id="ga925a72eb7e4c7417d0304e9872025218"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void runMergeSort </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>pkeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pvals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_merge_sort_plan.html">CUDPPMergeSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs merge sort utilizing 3 stages: (1) Blocksort, (2) simple merge and (3) multi merge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pkeys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pvals</td><td>Associated values to be sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for mergesort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad1ad99cc80465972cf1fb732b81ab8e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocMergeSortStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_merge_sort_plan.html">CUDPPMergeSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>From the programmer-specified sort configuration, creates internal memory for performing the sort. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_merge_sort_plan.html" title="Plan class for mergesort algorithm. ">CUDPPMergeSortPlan</a> object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga290ef022e420d9721f8cb15d1475c074"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeMergeSortStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_merge_sort_plan.html">CUDPPMergeSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates intermediate memory from allocRadixSortStorage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_merge_sort_plan.html" title="Plan class for mergesort algorithm. ">CUDPPMergeSortPlan</a> object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1cefde64490a053ec2453c0a7897840e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppMergeSortDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_merge_sort_plan.html">CUDPPMergeSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch function to perform a sort on an array with a specified configuration. </p>
<p>This is the dispatch routine which calls mergeSort...() with appropriate template parameters and arguments as specified by the plan. Currently only sorts keys of type int, unsigned int, and float. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Associated values to be sorted (through keys). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for mergeSort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabe9e54e5981e89eb37ca229b358ef364"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename bucket_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void multisplit_key_only </td>
          <td>(</td>
          <td class="paramtype">key_type *&#160;</td>
          <td class="paramname"><em>d_key_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_type *&#160;</td>
          <td class="paramname"><em>d_key_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_buckets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">multisplit_context &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bucket_t&#160;</td>
          <td class="paramname"><em>bucket_identifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>in_place</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>bucket_offsets</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs multisplit on keys only. </p>
<p>This function performs multisplit on a list of keys for a number of buckets less than or equal to 32. If the number of buckets is less than a threshold, a warp-level multisplit is used. If the number of buckets is greater than the threshold, a block-level multisplit is used. This function also supports copying the results of multisplit back into the input array. In addition, the offset indices marking the locations of the buckets in the result array can optionally be saved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_key_in</td><td>Input keys to be multisplit. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_key_out</td><td>Output keys after multisplit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_elements</td><td>Number of elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_buckets</td><td>Number of buckets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Intermediate data storage for multisplit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bucket_identifier</td><td>Functor to map an element to a bucket number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_place</td><td>Flag to indicate if results are copied back to the input. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bucket_offsets</td><td>Optional output list of bucket indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad00c9b5e0fcf14a2bc5e6a2b95db4cee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_type , typename value_type , typename bucket_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void multisplit_key_value </td>
          <td>(</td>
          <td class="paramtype">key_type *&#160;</td>
          <td class="paramname"><em>d_key_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type *&#160;</td>
          <td class="paramname"><em>d_value_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_type *&#160;</td>
          <td class="paramname"><em>d_key_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type *&#160;</td>
          <td class="paramname"><em>d_value_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_buckets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">multisplit_context &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bucket_t&#160;</td>
          <td class="paramname"><em>bucket_identifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>in_place</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>bucket_offsets</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs multisplit on key-value pairs. </p>
<p>This function performs multisplit on a list of keys and a list of values for a number of buckets less than or equal to 32. If the number of buckets is less than a threshold, a warp-level multisplit is used. If the number of buckets is greater than the threshold, a block-level multisplit is used. This function also supports copying the results of multisplit back into the key and value input arrays. In addition, the offset indices marking the locations of the buckets in the result arrays can optionally be saved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_key_in</td><td>Input keys to be multisplit. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_value_in</td><td>Input values to be multisplit along with keys. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_key_out</td><td>Output keys after multisplit. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_value_out</td><td>Output keys after multisplit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_elements</td><td>Number of elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_buckets</td><td>Number of buckets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Intermediate data storage for multisplit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bucket_identifier</td><td>Functor to map an element to a bucket number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_place</td><td>Flag to indicate if results are copied back to inputs. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bucket_offsets</td><td>Optional output list of bucket indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga06d2262eaa85864e55a41d2fd928e40a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void reducedBitSortKeysOnly </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numBuckets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>bucketMapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_multi_split_plan.html">CUDPPMultiSplitPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs multisplit on keys only using the reduced-bit sort method. </p>
<p>This function uses radix sort to perform a multisplit. It is suitable when the number of buckets is large.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_inp</td><td>Keys to be multisplit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numBuckets</td><td>Number of buckets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bucketMapper</td><td>Functor that maps an element to a bucket number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration plan for multisplit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae9c4e43f381a68868933cd06a4b1a2fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void reducedBitSortKeyValue </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numBuckets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>bucketMapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_multi_split_plan.html">CUDPPMultiSplitPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs multisplit on key-value pairs using a reduced-bit sort. </p>
<p>This function uses radix sort to perform a multisplit on a list of keys and a list of values. It is suitable when the number of buckets is large.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_keys</td><td>Keys to be multisplit. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_values</td><td>Associated values to be multisplit </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of key-value pairs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numBuckets</td><td>Number of buckets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bucketMapper</td><td>Functor that maps an element to a bucket number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for multisplit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8798342dd9653776ff1687bbbf76720c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocMultiSplitStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_multi_split_plan.html">CUDPPMultiSplitPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>From the programmer-specified multisplit configuration, creates internal memory for performing the multisplit. Different storage amounts are required depending on the number of buckets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_multi_split_plan.html" title="Plan class for MultiSplit. ">CUDPPMultiSplitPlan</a> object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga75966035d042dd09df5dfa1231b95bb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeMultiSplitStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_multi_split_plan.html">CUDPPMultiSplitPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates intermediate memory from allocMultiSplitStorage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_multi_split_plan.html" title="Plan class for MultiSplit. ">CUDPPMultiSplitPlan</a> object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9463637ddddc629a85fde7c5edca5b5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppMultiSplitDispatch </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBuckets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BucketMappingFunc&#160;</td>
          <td class="paramname"><em>bucketMappingFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_multi_split_plan.html">CUDPPMultiSplitPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch function to perform multisplit on an array of elements into a number of buckets. </p>
<p>This is the dispatch routine which calls multiSplit...() with appropriate parameters, including the bucket mapping function specified by plan's configuration.</p>
<p>Currently only splits unsigned integers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be split. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Optional associated values to be split (through keys), can be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements to be split. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for multiSplit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa6043ddac717a99c471bb3dc0fc3c0de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocRadixSortStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>From the programmer-specified sort configuration, creates internal memory for performing the sort. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_radix_sort_plan.html" title="Plan class for radixsort algorithm. ">CUDPPRadixSortPlan</a> object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5b103658becc8dbb8c5ca1026ff61598"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeRadixSortStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates intermediate memory from allocRadixSortStorage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_radix_sort_plan.html" title="Plan class for radixsort algorithm. ">CUDPPRadixSortPlan</a> object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga75c1c0e157a23d4747fc2ae94570aab0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppRadixSortDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch function to perform a sort on an array with a specified configuration. </p>
<p>This is the dispatch routine which calls radixSort...() with appropriate template parameters and arguments as specified by the plan. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Associated values to be sorted (through keys). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for RadixSort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf341dae6c968df2f279c2fad825260b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void KeyValueSort </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Radix Sort kernel from NVlab cub library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_elements</td><td>Number of elements to sort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys</td><td>Key values of the elements in the array to be sorted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_values</td><td>Positions of the elements in the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa21194947434a2c765a167a466dfe71a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ComputeSA </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_keys_sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>str_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mgpu::CudaContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_sa_plan.html">CUDPPSaPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>stage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform Suffix Array (SA) using skew algorithm. </p>
<p>Performs recursive skew kernel on a given character string. A suffix array is a sorted array of all suffixes of a string. Skew algorithm is a linear-time algorithm based on divde and conquer. The SA of a string can be used as an index to quickly locate every occurrence of a substring pattern within the string. Suffix sorting algorithms can be used to compute the Burrows-Wheeler Transform(BWT). The BWT requires sorting of all cyclic permutations of a string, thus can be computed in linear time by using a suffix array of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_str</td><td>An unsigned int array of the input data stream to perform the SA on. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_sa</td><td>An array to store the output of the SA. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str_length</td><td>Total number of input elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Context format required by mgpu functions. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">plan</td><td>Pointer to the plan object used for this suffix array. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">offset</td><td>Offset to move head pointer to find the memory for each iteration. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stage</td><td>Stage for each iteration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaea92f85528a823aa09cee9a837f25257"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocSaStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_sa_plan.html">CUDPPSaPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate intermediate arrays used by suffix array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_sa_plan.html" title="Plan class for suffix array. ">CUDPPSaPlan</a> object containing options and number of elements, which is used to compute storage requirements, and within which intermediate storage is allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga70c30e805f5f2df3c3d3972277b6bdd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeSaStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_sa_plan.html">CUDPPSaPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate intermediate block arrays in a <a class="el" href="class_c_u_d_p_p_sa_plan.html" title="Plan class for suffix array. ">CUDPPSaPlan</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_sa_plan.html" title="Plan class for suffix array. ">CUDPPSaPlan</a> object initialized by <a class="el" href="group__cudpp__app.html#gaea92f85528a823aa09cee9a837f25257" title="Allocate intermediate arrays used by suffix array. ">allocSaStorage()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0d03d94fc60e03cbf736caf6edb0f3ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppSuffixArrayDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_keys_sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>d_str_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_sa_plan.html">CUDPPSaPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch function to perform parallel suffix array on a string with the specified configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_str</td><td>input string with three $ </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_sa</td><td>lexicographically sorted suffix position array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_str_length</td><td>Number of elements in the string including $ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_sa_plan.html" title="Plan class for suffix array. ">CUDPPSaPlan</a> object containing suffix_array options and intermediate storage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1642453a15896f873da0e378471ea809"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool isBackward, bool isExclusive, class Op &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scanArrayRecursive </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T **&#160;</td>
          <td class="paramname"><em>d_blockSums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>rowPitches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform recursive scan on arbitrary size arrays. </p>
<p>This is the CPU-side workhorse function of the scan engine. This function invokes the CUDA kernels which perform the scan on individual blocks.</p>
<p>Scans of large arrays must be split (possibly recursively) into a hierarchy of block scans, where each block is scanned by a single CUDA thread block. At each recursive level of the scanArrayRecursive first invokes a kernel to scan all blocks of that level, and if the level has more than one block, it calls itself recursively. On returning from each recursive level, the total sum of each block from the level below is added to all elements of the corresponding block in this level. See "Parallel Prefix Sum (Scan) in CUDA" for more information (see <a class="el" href="index.html#references">References </a> ).</p>
<p>Template parameter <em>T</em> is the datatype; <em>isBackward</em> specifies backward or forward scan; <em>isExclusive</em> specifies exclusive or inclusive scan, and <em>op</em> specifies the binary associative operator to be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>The output array for the scan results </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>The input array to be scanned </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_blockSums</td><td>Array of arrays of per-block sums (one array per recursive level, allocated by <a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6" title="Allocate intermediate arrays used by scan. ">allocScanStorage()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in the array to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRows</td><td>The number of rows in the array to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowPitches</td><td>Array of row pitches (one array per recursive level, allocated by <a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6" title="Allocate intermediate arrays used by scan. ">allocScanStorage()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The current recursive level of the scan </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga344e15dee4b3b2351c40bd9cc732bed6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocScanStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate intermediate arrays used by scan. </p>
<p>Scans of large arrays must be split (possibly recursively) into a hierarchy of block scans, where each block is scanned by a single CUDA thread block. At each recursive level of the scan, we need an array in which to store the total sums of all blocks in that level. This function computes the amount of storage needed and allocates it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm. ">CUDPPScanPlan</a> object containing options and number of elements, which is used to compute storage requirements, and within which intermediate storage is allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga399f5095b183ad026687fd227802ba5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeScanStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate intermediate block sums arrays in a <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm. ">CUDPPScanPlan</a> object. </p>
<p>These arrays must have been allocated by <a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6" title="Allocate intermediate arrays used by scan. ">allocScanStorage()</a>, which is called by the constructor of cudppScanPlan().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm. ">CUDPPScanPlan</a> object initialized by <a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6" title="Allocate intermediate arrays used by scan. ">allocScanStorage()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga49485cb95e21695293a9c35f8355336d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppScanDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch function to perform a scan (prefix sum) on an array with the specified configuration. </p>
<p>This is the dispatch routine which calls <a class="el" href="group__cudpp__app.html#ga1642453a15896f873da0e378471ea809" title="Perform recursive scan on arbitrary size arrays. ">scanArrayRecursive()</a> with appropriate template parameters and arguments to achieve the scan as specified in <em>plan</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>The output array of scan results </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>The input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRows</td><td>The number of rows to scan in parallel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm. ">CUDPPScanPlan</a> object containing scan options and intermediate storage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga810cdb458f43cab2fcd22a4e59da2354"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void runStringSort </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pkeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pvals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>stringVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stringArrayLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>termC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_string_sort_plan.html">CUDPPStringSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs merge sor utilzing three stages. (1) Blocksort, (2) simple merge and (3) multi merge on a set of strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pkeys</td><td>Keys (first four characters of string) to be sorted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pvals</td><td>Addresses of string locations for tie-breaks </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stringVals</td><td>global string value array (four characters stuffed into a uint) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringArrayLength</td><td>The size of our string array in uints (4 chars per uint) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for mergesort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">termC</td><td>Termination character for our strings </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabe53de69a1cdb089b31247af9d0211a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocStringSortStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_string_sort_plan.html">CUDPPStringSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>From the programmer-specified sort configuration, creates internal memory for performing the sort. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_string_sort_plan.html" title="Plan class for stringsort algorithm. ">CUDPPStringSortPlan</a> object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9270888514859ed9d40a3fc310521cbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeStringSortStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_string_sort_plan.html">CUDPPStringSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates intermediate memory from allocStringSortStorage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to CUDPStringSortPlan object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga25da6df4c589fcc60584ed619118984d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppStringSortDispatch </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>stringVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stringArrayLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>termC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_string_sort_plan.html">CUDPPStringSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch function to perform a sort on an array with a specified configuration. </p>
<p>This is the dispatch routine which calls stringSort...() with appropriate template parameters and arguments as specified by the plan. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys (first four chars of string) to be sorted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Address of string values in array of null terminated strings </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringVals</td><td>Global string array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringArrayLength</td><td>The size of our string array in uints (4 chars per uint) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">termC</td><td>Termination character for our strings </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for mergeSort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae845df54c4ceb644b405f45e52f5cc17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void crpcr </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>systemSizeOriginal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numSystems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hybrid CR-PCR solver (CRPCR) </p>
<p>This is a wrapper function for the GPU CR-PCR kernel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_x</td><td>Solution vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_a</td><td>Lower diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_b</td><td>Main diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_c</td><td>Upper diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_d</td><td>Right hand side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemSizeOriginal</td><td>The size of the linear system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numSystems</td><td>The number of systems to be solved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0509ed92fe9640a9d7ea1ce9cfa639d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppTridiagonalDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>systemSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numSystems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_tridiagonal_plan.html">CUDPPTridiagonalPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatches the tridiagonal function based on the plan. </p>
<p>This is the dispatch call for the tridiagonal solver in either float or double datatype.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_x</td><td>Solution vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_a</td><td>Lower diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_b</td><td>Main diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_c</td><td>Upper diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_d</td><td>Right hand side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemSize</td><td>The size of the linear system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numSystems</td><td>The number of systems to be solved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>pointer to <a class="el" href="class_c_u_d_p_p_tridiagonal_plan.html" title="Plan class for tridiagonal solver. ">CUDPPTridiagonalPlan</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Nov 30 2016 15:29:12 for CUDPP by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
