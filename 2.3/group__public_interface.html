<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>CUDPP: CUDPP Public Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUDPP
   &#160;<span id="projectnumber">2.3</span>
   </div>
   <div id="projectbrief">CUDA Data-Parallel Primitives Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">CUDPP Public Interface</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Algorithm Interface</h2></td></tr>
<tr class="memitem:ga19f4711b5219ff1fd4851fda0398d547"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga19f4711b5219ff1fd4851fda0398d547">cudppScan</a> (const CUDPPHandle planHandle, void *d_out, const void *d_in, size_t numElements)</td></tr>
<tr class="memdesc:ga19f4711b5219ff1fd4851fda0398d547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a scan operation of numElements on its input in GPU memory (d_in) and places the output in GPU memory (d_out), with the scan parameters specified in the plan pointed to by planHandle.  <a href="#ga19f4711b5219ff1fd4851fda0398d547">More...</a><br /></td></tr>
<tr class="separator:ga19f4711b5219ff1fd4851fda0398d547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf71eb423ec3252ca122e5c01b055fa51"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gaf71eb423ec3252ca122e5c01b055fa51">cudppSegmentedScan</a> (const CUDPPHandle planHandle, void *d_out, const void *d_idata, const unsigned int *d_iflags, size_t numElements)</td></tr>
<tr class="memdesc:gaf71eb423ec3252ca122e5c01b055fa51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a segmented scan operation of numElements on its input in GPU memory (d_idata) and places the output in GPU memory (d_out), with the scan parameters specified in the plan pointed to by planHandle.  <a href="#gaf71eb423ec3252ca122e5c01b055fa51">More...</a><br /></td></tr>
<tr class="separator:gaf71eb423ec3252ca122e5c01b055fa51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9655b51dba16bc43b8adee4507dc1d0"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gad9655b51dba16bc43b8adee4507dc1d0">cudppMultiScan</a> (const CUDPPHandle planHandle, void *d_out, const void *d_in, size_t numElements, size_t numRows)</td></tr>
<tr class="memdesc:gad9655b51dba16bc43b8adee4507dc1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs numRows parallel scan operations of numElements each on its input (d_in) and places the output in d_out, with the scan parameters set by config. Exactly like cudppScan except that it runs on multiple rows in parallel.  <a href="#gad9655b51dba16bc43b8adee4507dc1d0">More...</a><br /></td></tr>
<tr class="separator:gad9655b51dba16bc43b8adee4507dc1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3fd0152a8e5b1860b1b7b09a3753ae0"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gab3fd0152a8e5b1860b1b7b09a3753ae0">cudppCompact</a> (const CUDPPHandle planHandle, void *d_out, size_t *d_numValidElements, const void *d_in, const unsigned int *d_isValid, size_t numElements)</td></tr>
<tr class="memdesc:gab3fd0152a8e5b1860b1b7b09a3753ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an array <em>d_in</em> and an array of 1/0 flags in <em>deviceValid</em>, returns a compacted array in <em>d_out</em> of corresponding only the "valid" values from <em>d_in</em>.  <a href="#gab3fd0152a8e5b1860b1b7b09a3753ae0">More...</a><br /></td></tr>
<tr class="separator:gab3fd0152a8e5b1860b1b7b09a3753ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21d9b2b3c74daffbec52ef628f835313"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga21d9b2b3c74daffbec52ef628f835313">cudppReduce</a> (const CUDPPHandle planHandle, void *d_out, const void *d_in, size_t numElements)</td></tr>
<tr class="memdesc:ga21d9b2b3c74daffbec52ef628f835313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces an array to a single element using a binary associative operator.  <a href="#ga21d9b2b3c74daffbec52ef628f835313">More...</a><br /></td></tr>
<tr class="separator:ga21d9b2b3c74daffbec52ef628f835313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42ab36458601690c1ccc8321357755a5"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga42ab36458601690c1ccc8321357755a5">cudppRadixSort</a> (const CUDPPHandle planHandle, void *d_keys, void *d_values, size_t numElements)</td></tr>
<tr class="memdesc:ga42ab36458601690c1ccc8321357755a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts key-value pairs or keys only.  <a href="#ga42ab36458601690c1ccc8321357755a5">More...</a><br /></td></tr>
<tr class="separator:ga42ab36458601690c1ccc8321357755a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dfdfa4fd5c580302c5ab61b45c53b0a"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga6dfdfa4fd5c580302c5ab61b45c53b0a">cudppMergeSort</a> (const CUDPPHandle planHandle, void *d_keys, void *d_values, size_t numElements)</td></tr>
<tr class="memdesc:ga6dfdfa4fd5c580302c5ab61b45c53b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts key-value pairs or keys only.  <a href="#ga6dfdfa4fd5c580302c5ab61b45c53b0a">More...</a><br /></td></tr>
<tr class="separator:ga6dfdfa4fd5c580302c5ab61b45c53b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga477a2a43197b1f2f55122d3382896372"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga477a2a43197b1f2f55122d3382896372">cudppStringSortAligned</a> (const CUDPPHandle planHandle, unsigned int *d_keys, unsigned int *d_values, unsigned int *stringVals, size_t numElements, size_t stringArrayLength)</td></tr>
<tr class="memdesc:ga477a2a43197b1f2f55122d3382896372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts strings. Keys are the first four characters of the string, and values are the addresses where the strings reside in memory (stringVals)  <a href="#ga477a2a43197b1f2f55122d3382896372">More...</a><br /></td></tr>
<tr class="separator:ga477a2a43197b1f2f55122d3382896372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee8a05e38479c8b54b5d5b6655022d0a"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gaee8a05e38479c8b54b5d5b6655022d0a">cudppStringSort</a> (const CUDPPHandle planHandle, unsigned char *d_stringVals, unsigned int *d_address, unsigned char termC, size_t numElements, size_t stringArrayLength)</td></tr>
<tr class="memdesc:gaee8a05e38479c8b54b5d5b6655022d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts strings. Keys are the first four characters of the string, and values are the addresses where the strings reside in memory (stringVals)  <a href="#gaee8a05e38479c8b54b5d5b6655022d0a">More...</a><br /></td></tr>
<tr class="separator:gaee8a05e38479c8b54b5d5b6655022d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeedaa3a7ec8bbd6770c6fbce3c4276c5"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gaeedaa3a7ec8bbd6770c6fbce3c4276c5">cudppSparseMatrixVectorMultiply</a> (const CUDPPHandle sparseMatrixHandle, void *d_y, const void *d_x)</td></tr>
<tr class="memdesc:gaeedaa3a7ec8bbd6770c6fbce3c4276c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform matrix-vector multiply y = A*x for arbitrary sparse matrix A and vector x.  <a href="#gaeedaa3a7ec8bbd6770c6fbce3c4276c5">More...</a><br /></td></tr>
<tr class="separator:gaeedaa3a7ec8bbd6770c6fbce3c4276c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac27c987891faceedf79598f744212c67"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gac27c987891faceedf79598f744212c67">cudppRand</a> (const CUDPPHandle planHandle, void *d_out, size_t numElements)</td></tr>
<tr class="memdesc:gac27c987891faceedf79598f744212c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rand puts <em>numElements</em> random 32-bit elements into <em>d_out</em>.  <a href="#gac27c987891faceedf79598f744212c67">More...</a><br /></td></tr>
<tr class="separator:gac27c987891faceedf79598f744212c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9120af9942d2553d2f376ede0f7079dd"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga9120af9942d2553d2f376ede0f7079dd">cudppRandSeed</a> (const CUDPPHandle planHandle, unsigned int seed)</td></tr>
<tr class="memdesc:ga9120af9942d2553d2f376ede0f7079dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the seed used for rand.  <a href="#ga9120af9942d2553d2f376ede0f7079dd">More...</a><br /></td></tr>
<tr class="separator:ga9120af9942d2553d2f376ede0f7079dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd3c1f97e1d22839756fd2594aaefb56"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gabd3c1f97e1d22839756fd2594aaefb56">cudppTridiagonal</a> (CUDPPHandle planHandle, void *d_a, void *d_b, void *d_c, void *d_d, void *d_x, int systemSize, int numSystems)</td></tr>
<tr class="memdesc:gabd3c1f97e1d22839756fd2594aaefb56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves tridiagonal linear systems.  <a href="#gabd3c1f97e1d22839756fd2594aaefb56">More...</a><br /></td></tr>
<tr class="separator:gabd3c1f97e1d22839756fd2594aaefb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d6e16e3dcf36a46be5bd98a675992c8"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga9d6e16e3dcf36a46be5bd98a675992c8">cudppCompress</a> (CUDPPHandle planHandle, unsigned char *d_uncompressed, int *d_bwtIndex, unsigned int *d_histSize, unsigned int *d_hist, unsigned int *d_encodeOffset, unsigned int *d_compressedSize, unsigned int *d_compressed, size_t numElements)</td></tr>
<tr class="memdesc:ga9d6e16e3dcf36a46be5bd98a675992c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compresses data stream.  <a href="#ga9d6e16e3dcf36a46be5bd98a675992c8">More...</a><br /></td></tr>
<tr class="separator:ga9d6e16e3dcf36a46be5bd98a675992c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab926c0dabcab709f71621a5c0eb45ea3"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gab926c0dabcab709f71621a5c0eb45ea3">cudppBurrowsWheelerTransform</a> (CUDPPHandle planHandle, unsigned char *d_in, unsigned char *d_out, int *d_index, size_t numElements)</td></tr>
<tr class="memdesc:gab926c0dabcab709f71621a5c0eb45ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the Burrows-Wheeler Transform.  <a href="#gab926c0dabcab709f71621a5c0eb45ea3">More...</a><br /></td></tr>
<tr class="separator:gab926c0dabcab709f71621a5c0eb45ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbb42fbc58ea70582dc1110c798ece38"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gadbb42fbc58ea70582dc1110c798ece38">cudppMoveToFrontTransform</a> (CUDPPHandle planHandle, unsigned char *d_in, unsigned char *d_out, size_t numElements)</td></tr>
<tr class="memdesc:gadbb42fbc58ea70582dc1110c798ece38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the Move-to-Front Transform.  <a href="#gadbb42fbc58ea70582dc1110c798ece38">More...</a><br /></td></tr>
<tr class="separator:gadbb42fbc58ea70582dc1110c798ece38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66d4b12b41fb30088353a8091c51f85a"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga66d4b12b41fb30088353a8091c51f85a">cudppListRank</a> (CUDPPHandle planHandle, void *d_ranked_values, void *d_unranked_values, void *d_next_indices, size_t head, size_t numElements)</td></tr>
<tr class="memdesc:ga66d4b12b41fb30088353a8091c51f85a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs list ranking of linked list node values.  <a href="#ga66d4b12b41fb30088353a8091c51f85a">More...</a><br /></td></tr>
<tr class="separator:ga66d4b12b41fb30088353a8091c51f85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf9b40f6aaa7039aff1aa33a441d980f"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gabf9b40f6aaa7039aff1aa33a441d980f">cudppSuffixArray</a> (CUDPPHandle planHandle, unsigned char *d_in, unsigned int *d_out, size_t numElements)</td></tr>
<tr class="memdesc:gabf9b40f6aaa7039aff1aa33a441d980f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the Suffix Array.  <a href="#gabf9b40f6aaa7039aff1aa33a441d980f">More...</a><br /></td></tr>
<tr class="separator:gabf9b40f6aaa7039aff1aa33a441d980f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61549b462de6627af02cc628ead17d22"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga61549b462de6627af02cc628ead17d22">cudppMultiSplit</a> (const CUDPPHandle planHandle, unsigned int *d_keys, unsigned int *d_values, size_t numElements, size_t numBuckets)</td></tr>
<tr class="memdesc:ga61549b462de6627af02cc628ead17d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits an array of keys and an optional array of values into a set of buckets.  <a href="#ga61549b462de6627af02cc628ead17d22">More...</a><br /></td></tr>
<tr class="separator:ga61549b462de6627af02cc628ead17d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga456800cc09f78c4dac6f48cf53b60e3c"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga456800cc09f78c4dac6f48cf53b60e3c">cudppMultiSplitCustomBucketMapper</a> (const CUDPPHandle planHandle, unsigned int *d_keys, unsigned int *d_values, size_t numElements, size_t numBuckets, BucketMappingFunc bucketMappingFunc)</td></tr>
<tr class="memdesc:ga456800cc09f78c4dac6f48cf53b60e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits an array of keys and an optional array of values into a set of buckets using a custom function to map elements to buckets.  <a href="#ga456800cc09f78c4dac6f48cf53b60e3c">More...</a><br /></td></tr>
<tr class="separator:ga456800cc09f78c4dac6f48cf53b60e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Library Management Interface</h2></td></tr>
<tr class="memitem:ga9156a26943f99d0fff44d218129631b4"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga9156a26943f99d0fff44d218129631b4">cudppCreate</a> (CUDPPHandle *theCudpp)</td></tr>
<tr class="memdesc:ga9156a26943f99d0fff44d218129631b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the CUDPP library, and returns a handle.  <a href="#ga9156a26943f99d0fff44d218129631b4">More...</a><br /></td></tr>
<tr class="separator:ga9156a26943f99d0fff44d218129631b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b98b05d585860ec4fcc44472244d01b"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga8b98b05d585860ec4fcc44472244d01b">cudppDestroy</a> (CUDPPHandle theCudpp)</td></tr>
<tr class="memdesc:ga8b98b05d585860ec4fcc44472244d01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an instance of the CUDPP library given its handle.  <a href="#ga8b98b05d585860ec4fcc44472244d01b">More...</a><br /></td></tr>
<tr class="separator:ga8b98b05d585860ec4fcc44472244d01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Plan Interface</h2></td></tr>
<tr class="memitem:ga31fd56135f9c8f73da79af83a958f27c"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c">cudppPlan</a> (const CUDPPHandle cudppHandle, CUDPPHandle *planHandle, <a class="el" href="struct_c_u_d_p_p_configuration.html">CUDPPConfiguration</a> config, size_t numElements, size_t numRows, size_t rowPitch)</td></tr>
<tr class="memdesc:ga31fd56135f9c8f73da79af83a958f27c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a CUDPP plan.  <a href="#ga31fd56135f9c8f73da79af83a958f27c">More...</a><br /></td></tr>
<tr class="separator:ga31fd56135f9c8f73da79af83a958f27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4015898886e140ad95f320ab4c07db2c"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga4015898886e140ad95f320ab4c07db2c">cudppDestroyPlan</a> (CUDPPHandle planHandle)</td></tr>
<tr class="memdesc:ga4015898886e140ad95f320ab4c07db2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a CUDPP Plan.  <a href="#ga4015898886e140ad95f320ab4c07db2c">More...</a><br /></td></tr>
<tr class="separator:ga4015898886e140ad95f320ab4c07db2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc6c2587fe06dadd93fb1d69ba836d84"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gabc6c2587fe06dadd93fb1d69ba836d84">cudppSparseMatrix</a> (const CUDPPHandle cudppHandle, CUDPPHandle *sparseMatrixHandle, <a class="el" href="struct_c_u_d_p_p_configuration.html">CUDPPConfiguration</a> config, size_t numNonZeroElements, size_t numRows, const void *A, const unsigned int *h_rowIndices, const unsigned int *h_indices)</td></tr>
<tr class="memdesc:gabc6c2587fe06dadd93fb1d69ba836d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a CUDPP Sparse Matrix Object.  <a href="#gabc6c2587fe06dadd93fb1d69ba836d84">More...</a><br /></td></tr>
<tr class="separator:gabc6c2587fe06dadd93fb1d69ba836d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0644c758120abaef0e2bb396f57cefb"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gae0644c758120abaef0e2bb396f57cefb">cudppDestroySparseMatrix</a> (CUDPPHandle sparseMatrixHandle)</td></tr>
<tr class="memdesc:gae0644c758120abaef0e2bb396f57cefb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a CUDPP Sparse Matrix Object.  <a href="#gae0644c758120abaef0e2bb396f57cefb">More...</a><br /></td></tr>
<tr class="separator:gae0644c758120abaef0e2bb396f57cefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Hash Table Interface</h2></td></tr>
<tr class="memitem:ga735902f6999db2580e1b17912cbd3eae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga735902f6999db2580e1b17912cbd3eae"></a>
const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>CUDPP_HASH_KEY_NOT_FOUND</b> = CudaHT::CuckooHashing::kNotFound</td></tr>
<tr class="separator:ga735902f6999db2580e1b17912cbd3eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cd993f24223a9e5b59fc84bff5be22b"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga0cd993f24223a9e5b59fc84bff5be22b">cudppHashTable</a> (CUDPPHandle cudppHandle, CUDPPHandle *plan, const <a class="el" href="struct_c_u_d_p_p_hash_table_config.html">CUDPPHashTableConfig</a> *config)</td></tr>
<tr class="memdesc:ga0cd993f24223a9e5b59fc84bff5be22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a CUDPP hash table in GPU memory given an input hash table configuration; returns the <em>plan</em> for that hash table.  <a href="#ga0cd993f24223a9e5b59fc84bff5be22b">More...</a><br /></td></tr>
<tr class="separator:ga0cd993f24223a9e5b59fc84bff5be22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa93793870394fdb90859d6f1e0ff662b"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gaa93793870394fdb90859d6f1e0ff662b">cudppHashInsert</a> (CUDPPHandle plan, const void *d_keys, const void *d_vals, size_t num)</td></tr>
<tr class="memdesc:gaa93793870394fdb90859d6f1e0ff662b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts keys and values into a CUDPP hash table.  <a href="#gaa93793870394fdb90859d6f1e0ff662b">More...</a><br /></td></tr>
<tr class="separator:gaa93793870394fdb90859d6f1e0ff662b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a351e4f3c9d69e3111c3463784e7ebe"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga8a351e4f3c9d69e3111c3463784e7ebe">cudppHashRetrieve</a> (CUDPPHandle plan, const void *d_keys, void *d_vals, size_t num)</td></tr>
<tr class="memdesc:ga8a351e4f3c9d69e3111c3463784e7ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves values, given keys, from a CUDPP hash table.  <a href="#ga8a351e4f3c9d69e3111c3463784e7ebe">More...</a><br /></td></tr>
<tr class="separator:ga8a351e4f3c9d69e3111c3463784e7ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac78326e26664036e8526de8f7a662c0f"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gac78326e26664036e8526de8f7a662c0f">cudppDestroyHashTable</a> (CUDPPHandle cudppHandle, CUDPPHandle plan)</td></tr>
<tr class="memdesc:gac78326e26664036e8526de8f7a662c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a hash table given its handle.  <a href="#gac78326e26664036e8526de8f7a662c0f">More...</a><br /></td></tr>
<tr class="separator:gac78326e26664036e8526de8f7a662c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab1189a6b1ce8ebb63c02ef46acd9595"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gaab1189a6b1ce8ebb63c02ef46acd9595">cudppMultivalueHashGetValuesSize</a> (CUDPPHandle plan, unsigned int *size)</td></tr>
<tr class="memdesc:gaab1189a6b1ce8ebb63c02ef46acd9595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the size of the values array in a multivalue hash table.  <a href="#gaab1189a6b1ce8ebb63c02ef46acd9595">More...</a><br /></td></tr>
<tr class="separator:gaab1189a6b1ce8ebb63c02ef46acd9595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b5e657c472ed38442fe45861836bc9d"><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga6b5e657c472ed38442fe45861836bc9d">cudppMultivalueHashGetAllValues</a> (CUDPPHandle plan, unsigned int **d_vals)</td></tr>
<tr class="memdesc:ga6b5e657c472ed38442fe45861836bc9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a pointer to the values array in a multivalue hash table.  <a href="#ga6b5e657c472ed38442fe45861836bc9d">More...</a><br /></td></tr>
<tr class="separator:ga6b5e657c472ed38442fe45861836bc9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The CUDA public interface comprises the functions, structs, and enums defined in <a class="el" href="cudpp_8h.html" title="Main library header file. Defines public interface. ">cudpp.h</a>. Public interface functions call functions in the <a class="el" href="group__cudpp__app.html">Application-Level</a> interface. The public interface functions include Plan Interface functions and Algorithm Interface functions. Plan Interface functions are used for creating CUDPP Plan objects that contain configuration details, intermediate storage space, and in the case of <a class="el" href="group__public_interface.html#gabc6c2587fe06dadd93fb1d69ba836d84" title="Create a CUDPP Sparse Matrix Object. ">cudppSparseMatrix()</a>, data. The Algorithm Interface is the set of functions that do the real work of CUDPP, such as <a class="el" href="group__public_interface.html#ga19f4711b5219ff1fd4851fda0398d547" title="Performs a scan operation of numElements on its input in GPU memory (d_in) and places the output in G...">cudppScan()</a> and <a class="el" href="group__public_interface.html#gaeedaa3a7ec8bbd6770c6fbce3c4276c5" title="Perform matrix-vector multiply y = A*x for arbitrary sparse matrix A and vector x. ">cudppSparseMatrixVectorMultiply()</a>. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga19f4711b5219ff1fd4851fda0398d547"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppScan </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a scan operation of numElements on its input in GPU memory (d_in) and places the output in GPU memory (d_out), with the scan parameters specified in the plan pointed to by planHandle. </p>
<p>The input to a scan operation is an input array, a binary associative operator (like + or max), and an identity element for that operator (+'s identity is 0). The output of scan is the same size as its input. Informally, the output at each element is the result of operator applied to each input that comes before it. For instance, the output of sum-scan at each element is the sum of all the input elements before that input.</p>
<p>More formally, for associative operator  &oplus;, <em>out<sub>i</sub></em> = <em>in<sub>0</sub></em>  &oplus; <em>in<sub>1</sub></em>  &oplus; ...  &oplus; <em>in<sub>i-1</sub></em>.</p>
<p>CUDPP supports "exclusive" and "inclusive" scans. For the ADD operator, an exclusive scan computes the sum of all input elements before the current element, while an inclusive scan computes the sum of all input elements up to and including the current element.</p>
<p>Before calling scan, create an internal plan using <a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan. ">cudppPlan()</a>.</p>
<p>After you are finished with the scan plan, clean up with <a class="el" href="group__public_interface.html#ga4015898886e140ad95f320ab4c07db2c" title="Destroy a CUDPP Plan. ">cudppDestroyPlan()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>Handle to plan for this scan </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>output of scan, in GPU memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>input to scan, in GPU memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>number of elements to scan </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan. ">cudppPlan</a>, <a class="el" href="group__public_interface.html#ga4015898886e140ad95f320ab4c07db2c" title="Destroy a CUDPP Plan. ">cudppDestroyPlan</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf71eb423ec3252ca122e5c01b055fa51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppSegmentedScan </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_idata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_iflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a segmented scan operation of numElements on its input in GPU memory (d_idata) and places the output in GPU memory (d_out), with the scan parameters specified in the plan pointed to by planHandle. </p>
<p>The input to a segmented scan operation is an input array of data, an input array of flags which demarcate segments, a binary associative operator (like + or max), and an identity element for that operator (+'s identity is 0). The array of flags is the same length as the input with 1 marking the the first element of a segment and 0 otherwise. The output of segmented scan is the same size as its input. Informally, the output at each element is the result of operator applied to each input that comes before it in that segment. For instance, the output of segmented sum-scan at each element is the sum of all the input elements before that input in that segment.</p>
<p>More formally, for associative operator  &oplus;, <em>out<sub>i</sub></em> = <em>in<sub>k</sub></em>  &oplus; <em>in<sub>k+1</sub></em>  &oplus; ...  &oplus; <em>in<sub>i-1</sub></em>. <em>k</em> is the index of the first element of the segment in which <em>i</em> lies.</p>
<p>We support both "exclusive" and "inclusive" variants. For a segmented sum-scan, the exclusive variant computes the sum of all input elements before the current element in that segment, while the inclusive variant computes the sum of all input elements up to and including the current element, in that segment.</p>
<p>Before calling segmented scan, create an internal plan using <a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan. ">cudppPlan()</a>.</p>
<p>After you are finished with the scan plan, clean up with <a class="el" href="group__public_interface.html#ga4015898886e140ad95f320ab4c07db2c" title="Destroy a CUDPP Plan. ">cudppDestroyPlan()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>Handle to plan for this scan </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>output of segmented scan, in GPU memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_idata</td><td>input data to segmented scan, in GPU memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_iflags</td><td>input flags to segmented scan, in GPU memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>number of elements to perform segmented scan on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan. ">cudppPlan</a>, <a class="el" href="group__public_interface.html#ga4015898886e140ad95f320ab4c07db2c" title="Destroy a CUDPP Plan. ">cudppDestroyPlan</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad9655b51dba16bc43b8adee4507dc1d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppMultiScan </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numRows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs numRows parallel scan operations of numElements each on its input (d_in) and places the output in d_out, with the scan parameters set by config. Exactly like cudppScan except that it runs on multiple rows in parallel. </p>
<p>Note that to achieve good performance with cudppMultiScan one should allocate the device arrays passed to it so that all rows are aligned to the correct boundaries for the architecture the app is running on. The easy way to do this is to use cudaMallocPitch() to allocate a 2D array on the device. Use the <em>rowPitch</em> parameter to <a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan. ">cudppPlan()</a> to specify this pitch. The easiest way is to pass the device pitch returned by cudaMallocPitch to <a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan. ">cudppPlan()</a> via <em>rowPitch</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>handle to <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm. ">CUDPPScanPlan</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>output of scan, in GPU memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>input to scan, in GPU memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>number of elements (per row) to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRows</td><td>number of rows to scan in parallel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public_interface.html#ga19f4711b5219ff1fd4851fda0398d547" title="Performs a scan operation of numElements on its input in GPU memory (d_in) and places the output in G...">cudppScan</a>, <a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan. ">cudppPlan</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab3fd0152a8e5b1860b1b7b09a3753ae0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppCompact </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>d_numValidElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_isValid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an array <em>d_in</em> and an array of 1/0 flags in <em>deviceValid</em>, returns a compacted array in <em>d_out</em> of corresponding only the "valid" values from <em>d_in</em>. </p>
<p>Takes as input an array of elements in GPU memory (<em>d_in</em>) and an equal-sized unsigned int array in GPU memory (<em>deviceValid</em>) that indicate which of those input elements are valid. The output is a packed array, in GPU memory, of only those elements marked as valid.</p>
<p>Internally, uses cudppScan.</p>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;d_in    = [ a b c d e f ]</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;deviceValid = [ 1 0 1 1 0 1 ]</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;d_out   = [ a c d f ]</div></div><!-- fragment --><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>[MJH] We need to evaluate whether cudppCompact should be a core member of the public interface. It's not clear to me that what the user always wants is a final compacted array. Often one just wants the array of indices to which each input element should go in the output. The split() routine used in radix sort might make more sense to expose.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>handle to <a class="el" href="class_c_u_d_p_p_compact_plan.html" title="Plan class for compact algorithm. ">CUDPPCompactPlan</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>compacted output </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_numValidElements</td><td>set during cudppCompact; is set with the number of elements valid flags in the d_isValid input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>input to compact </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_isValid</td><td>which elements in d_in are valid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>number of elements in d_in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition </dd></dl>

</div>
</div>
<a class="anchor" id="ga21d9b2b3c74daffbec52ef628f835313"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppReduce </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces an array to a single element using a binary associative operator. </p>
<p>For example, if the operator is CUDPP_ADD, then: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;d_in    = [ 3 2 0 1 -4 5 0 -1 ]</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;d_out   = [ 6 ]</div></div><!-- fragment --><p>If the operator is CUDPP_MIN, then: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;d_in    = [ 3 2 0 1 -4 5 0 -1 ]</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;d_out   = [ -4 ]</div></div><!-- fragment --><p>Limits: <em>numElements</em> must be at least 1, and is currently limited only by the addressable memory in CUDA (and the output accuracy is limited by numerical precision).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>handle to <a class="el" href="class_c_u_d_p_p_reduce_plan.html" title="Plan class for reduce algorithm. ">CUDPPReducePlan</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>Output of reduce (a single element) in GPU memory. Must be a pointer to an array of at least a single element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>Input array to reduce in GPU memory. Must be a pointer to an array of at least <em>numElements</em> elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>the number of elements to reduce. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan. ">cudppPlan</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga42ab36458601690c1ccc8321357755a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppRadixSort </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts key-value pairs or keys only. </p>
<p>Takes as input an array of keys in GPU memory (d_keys) and an optional array of corresponding values, and outputs sorted arrays of keys and (optionally) values in place. Radix sort or Merge sort is selected through the configuration (.algorithm) Key-value and key-only sort is selected through the configuration of the plan, using the options CUDPP_OPTION_KEYS_ONLY and CUDPP_OPTION_KEY_VALUE_PAIRS.</p>
<p>Supported key types are CUDPP_FLOAT and CUDPP_UINT. Values can be any 32-bit type (internally, values are treated only as a payload and cast to unsigned int).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>Determine if we need to provide an "out of place" sort interface.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>handle to CUDPPSortPlan </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys</td><td>keys by which key-value pairs will be sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_values</td><td>values to be sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>number of elements in d_keys and d_values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan. ">cudppPlan</a>, <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when creating a plan ...">CUDPPConfiguration</a>, <a class="el" href="cudpp_8h.html#a6499e5c26f56db82f520367ae853462f" title="Algorithms supported by CUDPP. Used to create appropriate plans using cudppPlan. ">CUDPPAlgorithm</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6dfdfa4fd5c580302c5ab61b45c53b0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppMergeSort </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts key-value pairs or keys only. </p>
<p>Takes as input an array of keys in GPU memory (d_keys) and an optional array of corresponding values, and outputs sorted arrays of keys and (optionally) values in place. Radix sort or Merge sort is selected through the configuration (.algorithm) Key-value and key-only sort is selected through the configuration of the plan, using the options CUDPP_OPTION_KEYS_ONLY and CUDPP_OPTION_KEY_VALUE_PAIRS.</p>
<p>Supported key types are CUDPP_FLOAT and CUDPP_UINT. Values can be any 32-bit type (internally, values are treated only as a payload and cast to unsigned int).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>Determine if we need to provide an "out of place" sort interface.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>handle to CUDPPSortPlan </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys</td><td>keys by which key-value pairs will be sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_values</td><td>values to be sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>number of elements in d_keys and d_values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan. ">cudppPlan</a>, <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when creating a plan ...">CUDPPConfiguration</a>, <a class="el" href="cudpp_8h.html#a6499e5c26f56db82f520367ae853462f" title="Algorithms supported by CUDPP. Used to create appropriate plans using cudppPlan. ">CUDPPAlgorithm</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga477a2a43197b1f2f55122d3382896372"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppStringSortAligned </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>stringVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stringArrayLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts strings. Keys are the first four characters of the string, and values are the addresses where the strings reside in memory (stringVals) </p>
<p>Takes as input an array of strings (broken up as first four chars (key), addresses (values), and the strings themselves (stringVals) aligned by 4 character and packed into a uint)</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>Determine if we need to provide an "out of place" sort interface.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>handle to CUDPPSortPlan </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_keys</td><td>keys (first four chars of string to be sorted) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_values</td><td>addresses where the strings reside </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringVals</td><td>Packed String input, series of characters each terminated by a null </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>number of elements in d_keys and d_values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringArrayLength</td><td>Length in uint of the size of stromgVals </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan. ">cudppPlan</a>, <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when creating a plan ...">CUDPPConfiguration</a>, <a class="el" href="cudpp_8h.html#a6499e5c26f56db82f520367ae853462f" title="Algorithms supported by CUDPP. Used to create appropriate plans using cudppPlan. ">CUDPPAlgorithm</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaee8a05e38479c8b54b5d5b6655022d0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppStringSort </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_stringVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>termC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stringArrayLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts strings. Keys are the first four characters of the string, and values are the addresses where the strings reside in memory (stringVals) </p>
<p>Takes as input an array of strings arranged as a char* array with NULL terminating characters. This function will reformat this info into keys (first four chars) values(pointers to string array addresses) and aligned string value array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>handle to CUDPPSortPlan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_stringVals</td><td>Original string input, no need for alignment or offsets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_address</td><td>Pointers (in order) to each strings starting location in the stringVals array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">termC</td><td>Termination character used to separate strings </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>number of strings </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringArrayLength</td><td>Length in uint of the size of all strings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan. ">cudppPlan</a>, <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when creating a plan ...">CUDPPConfiguration</a>, <a class="el" href="cudpp_8h.html#a6499e5c26f56db82f520367ae853462f" title="Algorithms supported by CUDPP. Used to create appropriate plans using cudppPlan. ">CUDPPAlgorithm</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaeedaa3a7ec8bbd6770c6fbce3c4276c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppSparseMatrixVectorMultiply </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>sparseMatrixHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform matrix-vector multiply y = A*x for arbitrary sparse matrix A and vector x. </p>
<p>Given a matrix object handle (which has been initialized using <a class="el" href="group__public_interface.html#gabc6c2587fe06dadd93fb1d69ba836d84" title="Create a CUDPP Sparse Matrix Object. ">cudppSparseMatrix()</a>), This function multiplies the input vector <em>d_x</em> by the matrix referred to by <em>sparseMatrixHandle</em>, returning the result in <em>d_y</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sparseMatrixHandle</td><td>Handle to a sparse matrix object created with <a class="el" href="group__public_interface.html#gabc6c2587fe06dadd93fb1d69ba836d84" title="Create a CUDPP Sparse Matrix Object. ">cudppSparseMatrix()</a> </td></tr>
    <tr><td class="paramname">d_y</td><td>The output vector, y </td></tr>
    <tr><td class="paramname">d_x</td><td>The input vector, x </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public_interface.html#gabc6c2587fe06dadd93fb1d69ba836d84" title="Create a CUDPP Sparse Matrix Object. ">cudppSparseMatrix</a>, <a class="el" href="group__public_interface.html#gae0644c758120abaef0e2bb396f57cefb" title="Destroy a CUDPP Sparse Matrix Object. ">cudppDestroySparseMatrix</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac27c987891faceedf79598f744212c67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppRand </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rand puts <em>numElements</em> random 32-bit elements into <em>d_out</em>. </p>
<p>Outputs <em>numElements</em> random values to <em>d_out</em>. <em>d_out</em> must be of type unsigned int, allocated in device memory.</p>
<p>The algorithm used for the random number generation is stored in <em>planHandle</em>. Depending on the specification of the pseudo random number generator(PRNG), the generator may have one or more seeds. To set the seed, use <a class="el" href="group__public_interface.html#ga9120af9942d2553d2f376ede0f7079dd" title="Sets the seed used for rand. ">cudppRandSeed()</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>Currently only MD5 PRNG is supported. We may provide more rand routines in the future.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>Handle to plan for rand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>number of elements in d_out. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>output of rand, in GPU memory. Should be an array of unsigned integers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan. ">cudppPlan</a>, <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when creating a plan ...">CUDPPConfiguration</a>, <a class="el" href="cudpp_8h.html#a6499e5c26f56db82f520367ae853462f" title="Algorithms supported by CUDPP. Used to create appropriate plans using cudppPlan. ">CUDPPAlgorithm</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9120af9942d2553d2f376ede0f7079dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppRandSeed </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the seed used for rand. </p>
<p>The seed is crucial to any random number generator as it allows a sequence of random numbers to be replicated. Since there may be multiple different rand algorithms in CUDPP, cudppRandSeed uses <em>planHandle</em> to determine which seed to set. Each rand algorithm has its own unique set of seeds depending on what the algorithm needs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>the handle to the plan which specifies which rand seed to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>the value which the internal cudpp seed will be set to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition </dd></dl>

</div>
</div>
<a class="anchor" id="gabd3c1f97e1d22839756fd2594aaefb56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppTridiagonal </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>systemSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numSystems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves tridiagonal linear systems. </p>
<p>The solver uses a hybrid CR-PCR algorithm described in our papers "Fast
Fast Tridiagonal Solvers on the GPU" and "A Hybrid Method for Solving
Tridiagonal Systems on the GPU". (See the <a class="el" href="index.html#references">References </a> bibliography). Please refer to the papers for a complete description of the basic CR (Cyclic Reduction) and PCR (Parallel Cyclic Reduction) algorithms and their hybrid variants.</p>
<ul>
<li>Both float and double data types are supported.</li>
<li>Both power-of-two and non-power-of-two system sizes are supported.</li>
<li>The maximum system size could be limited by the maximum number of threads of a CUDA block, the number of registers per multiprocessor, and the amount of shared memory available. For example, on the GTX 280 GPU, the maximum system size is 512 for the float datatype, and 256 for the double datatype, which is limited by the size of shared memory in this case.</li>
<li>The maximum number of systems is 65535, that is the maximum number of one-dimensional blocks that could be launched in a kernel call. Users could launch the kernel multiple times to solve more systems if required.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_x</td><td>Solution vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>Handle to plan for tridiagonal solver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_a</td><td>Lower diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_b</td><td>Main diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_c</td><td>Upper diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_d</td><td>Right hand side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemSize</td><td>The size of the linear system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numSystems</td><td>The number of systems to be solved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan. ">cudppPlan</a>, <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when creating a plan ...">CUDPPConfiguration</a>, <a class="el" href="cudpp_8h.html#a6499e5c26f56db82f520367ae853462f" title="Algorithms supported by CUDPP. Used to create appropriate plans using cudppPlan. ">CUDPPAlgorithm</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9d6e16e3dcf36a46be5bd98a675992c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppCompress </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_uncompressed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>d_bwtIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_histSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_encodeOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_compressedSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_compressed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compresses data stream. </p>
<p>Performs compression using a three stage pipeline consisting of the Burrows-Wheeler transform, the move-to-front transform, and Huffman encoding. The compression algorithms are described in our paper "Parallel Lossless Data Compression on the GPU". (See the <a class="el" href="index.html#references">References </a> bibliography).</p>
<ul>
<li>Only unsigned char type is supported.</li>
<li>Currently, the input stream (d_uncompressed) must be a buffer of 1,048,576 (uchar) elements (~1MB).</li>
<li>The BWT Index (d_bwtIndex) is an integer number (int). This is used during the reverse-BWT stage.</li>
<li>The Histogram size pointer (d_histSize) can be ignored and can be passed a null pointer.</li>
<li>The Histrogram (d_hist) is a 256-entry (unsigned int) buffer. The histogram is used to construct the Huffman tree during decoding.</li>
<li>The Encoded offset table (d_encodeOffset) is a 256-entry (unsigned int) buffer. Since the input stream is compressed in blocks of 4096 characters, the offset table gives the starting offset of where each block starts in the compressed data (d_compressedSize). The very first uint at each starting offset gives the size (in words) of that corresponding compressed block. This allows us to decompress each 4096 character-block in parallel.</li>
<li>The size of compressed data (d_compressedSize) is a uint and gives the final size (in words) of the compressed data.</li>
<li>The compress data stream (d_compressed) is a uint buffer. The user should allocate enough memory for worst-case (no compression occurs).</li>
<li><em>numElements</em> is a uint and must be set to 1048576.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_bwtIndex</td><td>BWT Index (int) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_histSize</td><td>Histogram size (ignored, null ptr) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_hist</td><td>Histogram (256-entry, uint) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_encodeOffset</td><td>Encoded offset table (256-entry, uint) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_compressedSize</td><td>Size of compressed data (uint) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_compressed</td><td>Compressed data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>Handle to plan for compressor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_uncompressed</td><td>Uncompressed data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements to compress </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan. ">cudppPlan</a>, <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when creating a plan ...">CUDPPConfiguration</a>, <a class="el" href="cudpp_8h.html#a6499e5c26f56db82f520367ae853462f" title="Algorithms supported by CUDPP. Used to create appropriate plans using cudppPlan. ">CUDPPAlgorithm</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab926c0dabcab709f71621a5c0eb45ea3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppBurrowsWheelerTransform </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>d_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the Burrows-Wheeler Transform. </p>
<p>Performs a parallel Burrows-Wheeler transform on 1,048,576 elements. The BWT leverages a string-sort algorithm based on merge-sort.</p>
<ul>
<li>Currently, the BWT can only be performed on 1,048,576 (uchar) elements.</li>
<li>The transformed string is written to <em>d_x</em>.</li>
<li>The BWT index (used during the reverse-BWT) is recorded as an int in <em>d_index</em>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>Handle to plan for BWT </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_in</td><td>BWT Index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>Output data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_index</td><td>Input data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan. ">cudppPlan</a>, <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when creating a plan ...">CUDPPConfiguration</a>, <a class="el" href="cudpp_8h.html#a6499e5c26f56db82f520367ae853462f" title="Algorithms supported by CUDPP. Used to create appropriate plans using cudppPlan. ">CUDPPAlgorithm</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gadbb42fbc58ea70582dc1110c798ece38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppMoveToFrontTransform </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the Move-to-Front Transform. </p>
<p>Performs a parallel move-to-front transform on 1,048,576 elements. The MTF uses a scan-based algorithm to parallelize the computation. The MTF uses a scan-based algorithm described in our paper "Parallel
Lossless Data Compression on the GPU". (See the <a class="el" href="index.html#references">References </a> bibliography).</p>
<ul>
<li>Currently, the MTF can only be performed on 1,048,576 (uchar) elements.</li>
<li>The transformed string is written to <em>d_mtfOut</em>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>Handle to plan for MTF </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>Output data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>Input data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan. ">cudppPlan</a>, <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when creating a plan ...">CUDPPConfiguration</a>, <a class="el" href="cudpp_8h.html#a6499e5c26f56db82f520367ae853462f" title="Algorithms supported by CUDPP. Used to create appropriate plans using cudppPlan. ">CUDPPAlgorithm</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga66d4b12b41fb30088353a8091c51f85a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppListRank </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_ranked_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_unranked_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_next_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs list ranking of linked list node values. </p>
<p>Performs parallel list ranking on values of a linked-list using a pointer-jumping algorithm.</p>
<p>Takes as input an array of values in GPU memory (<em>d_unranked_values</em>) and an equal-sized int array in GPU memory (<em>d_next_indices</em>) that represents the next indices of the linked list. The index of the head node (<em>head</em>) is given as an unsigned int. The output (<em>d_ranked_values</em>) is an equal-sized array, in GPU memory, that has the values ranked in-order.</p>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;d_a     = [  f a c d b e  ]</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;d_b     = [ -1 4 3 5 2 0  ]</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;head    = 1</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;d_x     = [ a b c d e f ]</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>Handle to plan for list ranking </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_ranked_values</td><td>Output ranked values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_unranked_values</td><td>Input unranked values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_next_indices</td><td>Input next indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">head</td><td>Input head node index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>number of nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan. ">cudppPlan</a>, <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when creating a plan ...">CUDPPConfiguration</a>, <a class="el" href="cudpp_8h.html#a6499e5c26f56db82f520367ae853462f" title="Algorithms supported by CUDPP. Used to create appropriate plans using cudppPlan. ">CUDPPAlgorithm</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gabf9b40f6aaa7039aff1aa33a441d980f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppSuffixArray </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the Suffix Array. </p>
<p>Performs a parallel suffix array using linear-time recursive skew algorithm. The SA leverages a suffix-sort algorithm based on divide and conquer.</p>
<ul>
<li>The SA is GPU memory bounded, it needs about seven times size of input data.</li>
<li>Only unsigned char type is supported.</li>
<li>The input char array is transformed into an unsigned int array storing the key values followed by three 0s for the convinience of building triplets.</li>
<li>The output data is an unsigned int array storing the positions of the lexicographically sorted suffixes not including the last {0,0,0} triplet.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>Handle to plan for CUDPPSuffixArrayPlan </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_in</td><td>Input data </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>Output data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan. ">cudppPlan</a>, <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when creating a plan ...">CUDPPConfiguration</a>, <a class="el" href="cudpp_8h.html#a6499e5c26f56db82f520367ae853462f" title="Algorithms supported by CUDPP. Used to create appropriate plans using cudppPlan. ">CUDPPAlgorithm</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga61549b462de6627af02cc628ead17d22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppMultiSplit </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBuckets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits an array of keys and an optional array of values into a set of buckets. </p>
<p>Takes as input an array of keys in GPU memory (d_keys) and an optional array of corresponding values, and outputs an arrays of keys and (optionally) values in place, where the keys and values have been split into ordered buckets. Key-value or key-only multisplit is selected through the configuration of the plan, using the options CUDPP_OPTION_KEYS_ONLY or CUDPP_OPTION_KEY_VALUE_PAIRS. The function used to map a key to a bucket is selected through the configuration option 'bucket_mapper'. The current options are:</p>
<p>ORDERED_CYCLIC_BUCKET_MAPPER (default): bucket = (key % numElements) / ((numElements + numBuckets - 1) / numBuckets);</p>
<p>MSB_BUCKET_MAPPER: bucket = (key &gt;&gt; (32 - ceil(log2(numBuckets)))) % numBuckets;</p>
<p>Currently, the only supported key and value type is CUDPP_UINT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>Handle to plan for <a class="el" href="class_c_u_d_p_p_multi_split_plan.html" title="Plan class for MultiSplit. ">CUDPPMultiSplitPlan</a> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_keys</td><td>keys by which key-value pairs will be split </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_values</td><td>values to be split </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>number of elements in d_keys and d_values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numBuckets</td><td>Number of buckets </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan. ">cudppPlan</a>, <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when creating a plan ...">CUDPPConfiguration</a>, <a class="el" href="cudpp_8h.html#a6499e5c26f56db82f520367ae853462f" title="Algorithms supported by CUDPP. Used to create appropriate plans using cudppPlan. ">CUDPPAlgorithm</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga456800cc09f78c4dac6f48cf53b60e3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppMultiSplitCustomBucketMapper </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBuckets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BucketMappingFunc&#160;</td>
          <td class="paramname"><em>bucketMappingFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits an array of keys and an optional array of values into a set of buckets using a custom function to map elements to buckets. </p>
<p>Takes as input an array of keys in GPU memory (d_keys) and an optional array of corresponding values, and outputs an arrays of keys and (optionally) values in place, where the keys and values have been split into ordered buckets. Key-value or key-only multisplit is selected through the configuration of the plan, using the options CUDPP_OPTION_KEYS_ONLY or CUDPP_OPTION_KEY_VALUE_PAIRS. To use this function, the configuration option 'bucket_mapper' must be set to CUSTOM_BUCKET_MAPPER. This option lets the library know to use the custom function pointer, specified in the last argument, when assigning an element to a bucket. The user specified bucket mapper must be a function pointer to a device function that takes one unsigned int argument (the element) and returns an unsigned int (the bucket).</p>
<p>Currently, the only supported key and value type is CUDPP_UINT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>Handle to plan for BWT </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_keys</td><td>Input data </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_values</td><td>Output data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numBuckets</td><td>Number of buckets </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bucketMappingFunc</td><td>function that maps an element to a bucket </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan. ">cudppPlan</a>, <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when creating a plan ...">CUDPPConfiguration</a>, <a class="el" href="cudpp_8h.html#a6499e5c26f56db82f520367ae853462f" title="Algorithms supported by CUDPP. Used to create appropriate plans using cudppPlan. ">CUDPPAlgorithm</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9156a26943f99d0fff44d218129631b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppCreate </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle *&#160;</td>
          <td class="paramname"><em>theCudpp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the CUDPP library, and returns a handle. </p>
<p><a class="el" href="group__public_interface.html#ga9156a26943f99d0fff44d218129631b4" title="Creates an instance of the CUDPP library, and returns a handle. ">cudppCreate()</a> must be called before any other CUDPP function. In a multi-GPU application that uses multiple CUDA context, <a class="el" href="group__public_interface.html#ga9156a26943f99d0fff44d218129631b4" title="Creates an instance of the CUDPP library, and returns a handle. ">cudppCreate()</a> must be called once for each CUDA context. Each call returns a different handle, because each CUDA context (and the host thread that owns it) must use a separate instance of the CUDPP library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">theCudpp</td><td>a pointer to the CUDPPHandle for the created CUDPP instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition </dd></dl>

</div>
</div>
<a class="anchor" id="ga8b98b05d585860ec4fcc44472244d01b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppDestroy </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>theCudpp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys an instance of the CUDPP library given its handle. </p>
<p><a class="el" href="group__public_interface.html#ga8b98b05d585860ec4fcc44472244d01b" title="Destroys an instance of the CUDPP library given its handle. ">cudppDestroy()</a> should be called once for each handle created using <a class="el" href="group__public_interface.html#ga9156a26943f99d0fff44d218129631b4" title="Creates an instance of the CUDPP library, and returns a handle. ">cudppCreate()</a>, to ensure proper resource cleanup of all library instances.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theCudpp</td><td>the handle to the CUDPP instance to destroy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition </dd></dl>

</div>
</div>
<a class="anchor" id="ga31fd56135f9c8f73da79af83a958f27c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppPlan </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>cudppHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUDPPHandle *&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_u_d_p_p_configuration.html">CUDPPConfiguration</a>&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rowPitch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a CUDPP plan. </p>
<p>A plan is a data structure containing state and intermediate storage space that CUDPP uses to execute algorithms on data. A plan is created by passing to <a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan. ">cudppPlan()</a> a <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when creating a plan ...">CUDPPConfiguration</a> that specifies the algorithm, operator, datatype, and options. The size of the data must also be passed to <a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan. ">cudppPlan()</a>, in the <em>numElements</em>, <em>numRows</em>, and <em>rowPitch</em> arguments. These sizes are used to allocate internal storage space at the time the plan is created. The CUDPP planner may use the sizes, options, and information about the present hardware to choose optimal settings.</p>
<p>Note that <em>numElements</em> is the maximum size of the array to be processed with this plan. That means that a plan may be re-used to process (for example, to sort or scan) smaller arrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">planHandle</td><td>A pointer to an opaque handle to the internal plan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cudppHandle</td><td>A handle to an instance of the CUDPP library used for resource management </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>The configuration struct specifying algorithm and options </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The maximum number of elements to be processed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRows</td><td>The number of rows (for 2D operations) to be processed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowPitch</td><td>The pitch of the rows of input data, in elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition </dd></dl>

</div>
</div>
<a class="anchor" id="ga4015898886e140ad95f320ab4c07db2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppDestroyPlan </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a CUDPP Plan. </p>
<p>Deletes the plan referred to by <em>planHandle</em> and all associated internal storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>The CUDPPHandle to the plan to be destroyed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition </dd></dl>

</div>
</div>
<a class="anchor" id="gabc6c2587fe06dadd93fb1d69ba836d84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppSparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>cudppHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUDPPHandle *&#160;</td>
          <td class="paramname"><em>sparseMatrixHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_u_d_p_p_configuration.html">CUDPPConfiguration</a>&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numNonZeroElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>h_rowIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>h_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a CUDPP Sparse Matrix Object. </p>
<p>The sparse matrix plan is a data structure containing state and intermediate storage space that CUDPP uses to perform sparse matrix dense vector multiply. This plan is created by passing to <a class="el" href="class_c_u_d_p_p_sparse_matrix_vector_multiply_plan.html" title="Plan class for sparse-matrix dense-vector multiply. ">CUDPPSparseMatrixVectorMultiplyPlan()</a> a <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when creating a plan ...">CUDPPConfiguration</a> that specifies the algorithm (sprarse matrix-dense vector multiply) and datatype, along with the sparse matrix itself in CSR format. The number of non-zero elements in the sparse matrix must also be passed as <em>numNonZeroElements</em>. This is used to allocate internal storage space at the time the sparse matrix plan is created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sparseMatrixHandle</td><td>A pointer to an opaque handle to the sparse matrix object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cudppHandle</td><td>A handle to an instance of the CUDPP library used for resource management </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>The configuration struct specifying algorithm and options </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numNonZeroElements</td><td>The number of non zero elements in the sparse matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRows</td><td>This is the number of rows in y, x and A for y = A * x </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>The matrix data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h_rowIndices</td><td>An array containing the index of the start of each row in <em>A</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h_indices</td><td>An array containing the index of each nonzero element in <em>A</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition </dd></dl>

</div>
</div>
<a class="anchor" id="gae0644c758120abaef0e2bb396f57cefb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppDestroySparseMatrix </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>sparseMatrixHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a CUDPP Sparse Matrix Object. </p>
<p>Deletes the sparse matrix data and plan referred to by <em>sparseMatrixHandle</em> and all associated internal storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sparseMatrixHandle</td><td>The CUDPPHandle to the matrix object to be destroyed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating success or error condition </dd></dl>

</div>
</div>
<a class="anchor" id="ga0cd993f24223a9e5b59fc84bff5be22b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppHashTable </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>cudppHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUDPPHandle *&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_c_u_d_p_p_hash_table_config.html">CUDPPHashTableConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a CUDPP hash table in GPU memory given an input hash table configuration; returns the <em>plan</em> for that hash table. </p>
<p>Requires a CUDPPHandle for the CUDPP instance (to ensure thread safety); call <a class="el" href="group__public_interface.html#ga9156a26943f99d0fff44d218129631b4" title="Creates an instance of the CUDPP library, and returns a handle. ">cudppCreate()</a> to get this handle.</p>
<p>The hash table implementation requires hardware capability 2.0 or higher (64-bit atomic operations).</p>
<p>Hash table types and input parameters are discussed in CUDPPHashTableType and <a class="el" href="struct_c_u_d_p_p_hash_table_config.html" title="Configuration struct for creating a hash table (CUDPPHashTable()) ">CUDPPHashTableConfig</a>.</p>
<p>After you are finished with the hash table, clean up with <a class="el" href="group__public_interface.html#gac78326e26664036e8526de8f7a662c0f" title="Destroys a hash table given its handle. ">cudppDestroyHashTable()</a>.</p>
<p>See <a class="el" href="hash_overview.html">Overview of CUDPP hash tables</a> for an overview of CUDPP's hash table support.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cudppHandle</td><td>Handle to CUDPP instance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">plan</td><td>Handle to hash table instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Configuration for hash table to be created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating if creation was successful</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public_interface.html#ga9156a26943f99d0fff44d218129631b4" title="Creates an instance of the CUDPP library, and returns a handle. ">cudppCreate</a>, <a class="el" href="group__public_interface.html#gac78326e26664036e8526de8f7a662c0f" title="Destroys a hash table given its handle. ">cudppDestroyHashTable</a>, <a class="el" href="cudpp__hash_8h.html#aafb866af39fe4f36e06273bd472fc3ec" title="Supported types of hash tables. ">CUDPPHashTableType</a>, <a class="el" href="struct_c_u_d_p_p_hash_table_config.html" title="Configuration struct for creating a hash table (CUDPPHashTable()) ">CUDPPHashTableConfig</a>, <a class="el" href="hash_overview.html">Overview of CUDPP hash tables</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa93793870394fdb90859d6f1e0ff662b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppHashInsert </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts keys and values into a CUDPP hash table. </p>
<p>Requires a CUDPPHandle for the hash table instance; call <a class="el" href="group__public_interface.html#ga0cd993f24223a9e5b59fc84bff5be22b" title="Creates a CUDPP hash table in GPU memory given an input hash table configuration; returns the plan fo...">cudppHashTable()</a> to create the hash table and get this handle.</p>
<p><em>d_keys</em> and <em>d_values</em> should be in GPU memory. These should be pointers to arrays of unsigned ints.</p>
<p>Calls HashTable::Build internally.</p>
<p>See <a class="el" href="hash_overview.html">Overview of CUDPP hash tables</a> for an overview of CUDPP's hash table support.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Handle to hash table instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys</td><td>GPU pointer to keys to be inserted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_vals</td><td>GPU pointer to values to be inserted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Number of keys/values to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating if insertion was successful</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public_interface.html#ga0cd993f24223a9e5b59fc84bff5be22b" title="Creates a CUDPP hash table in GPU memory given an input hash table configuration; returns the plan fo...">cudppHashTable</a>, <a class="el" href="group__public_interface.html#ga8a351e4f3c9d69e3111c3463784e7ebe" title="Retrieves values, given keys, from a CUDPP hash table. ">cudppHashRetrieve</a>, HashTable::Build, CompactingHashTable::Build, MultivalueHashTable::Build, <a class="el" href="hash_overview.html">Overview of CUDPP hash tables</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8a351e4f3c9d69e3111c3463784e7ebe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppHashRetrieve </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves values, given keys, from a CUDPP hash table. </p>
<p>Requires a CUDPPHandle for the hash table instance; call <a class="el" href="group__public_interface.html#ga0cd993f24223a9e5b59fc84bff5be22b" title="Creates a CUDPP hash table in GPU memory given an input hash table configuration; returns the plan fo...">cudppHashTable()</a> to create the hash table and get this handle.</p>
<p><em>d_keys</em> and <em>d_values</em> should be in GPU memory. These should be pointers to arrays of unsigned ints.</p>
<p>Calls HashTable::Retrieve internally.</p>
<p>See <a class="el" href="hash_overview.html">Overview of CUDPP hash tables</a> for an overview of CUDPP's hash table support.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Handle to hash table instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys</td><td>GPU pointer to keys to be retrieved </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_vals</td><td>GPU pointer to values to be retrieved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Number of keys/values to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating if retrieval was successful</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public_interface.html#ga0cd993f24223a9e5b59fc84bff5be22b" title="Creates a CUDPP hash table in GPU memory given an input hash table configuration; returns the plan fo...">cudppHashTable</a>, cudppHashBuild, HashTable::Retrieve, CompactingHashTable::Retrieve, MultivalueHashTable::Retrieve, <a class="el" href="hash_overview.html">Overview of CUDPP hash tables</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac78326e26664036e8526de8f7a662c0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppDestroyHashTable </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>cudppHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a hash table given its handle. </p>
<p>Requires a CUDPPHandle for the CUDPP instance (to ensure thread safety); call <a class="el" href="group__public_interface.html#ga9156a26943f99d0fff44d218129631b4" title="Creates an instance of the CUDPP library, and returns a handle. ">cudppCreate()</a> to get this handle.</p>
<p>Requires a CUDPPHandle for the hash table instance; call <a class="el" href="group__public_interface.html#ga0cd993f24223a9e5b59fc84bff5be22b" title="Creates a CUDPP hash table in GPU memory given an input hash table configuration; returns the plan fo...">cudppHashTable()</a> to get this handle.</p>
<p>See <a class="el" href="hash_overview.html">Overview of CUDPP hash tables</a> for an overview of CUDPP's hash table support.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cudppHandle</td><td>Handle to CUDPP instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Handle to hash table instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating if destruction was successful</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public_interface.html#ga0cd993f24223a9e5b59fc84bff5be22b" title="Creates a CUDPP hash table in GPU memory given an input hash table configuration; returns the plan fo...">cudppHashTable</a>, <a class="el" href="hash_overview.html">Overview of CUDPP hash tables</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaab1189a6b1ce8ebb63c02ef46acd9595"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppMultivalueHashGetValuesSize </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the size of the values array in a multivalue hash table. </p>
<p>Only relevant for multivalue hash tables.</p>
<p>Requires a CUDPPHandle for the hash table instance; call <a class="el" href="group__public_interface.html#ga0cd993f24223a9e5b59fc84bff5be22b" title="Creates a CUDPP hash table in GPU memory given an input hash table configuration; returns the plan fo...">cudppHashTable()</a> to get this handle.</p>
<p>See <a class="el" href="hash_overview.html">Overview of CUDPP hash tables</a> for an overview of CUDPP's hash table support.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Handle to hash table instance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>Pointer to size of multivalue hash table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating if operation was successful</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public_interface.html#ga0cd993f24223a9e5b59fc84bff5be22b" title="Creates a CUDPP hash table in GPU memory given an input hash table configuration; returns the plan fo...">cudppHashTable</a>, <a class="el" href="group__public_interface.html#ga6b5e657c472ed38442fe45861836bc9d" title="Retrieves a pointer to the values array in a multivalue hash table. ">cudppMultivalueHashGetAllValues</a>, <a class="el" href="hash_overview.html">Overview of CUDPP hash tables</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6b5e657c472ed38442fe45861836bc9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppMultivalueHashGetAllValues </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int **&#160;</td>
          <td class="paramname"><em>d_vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a pointer to the values array in a multivalue hash table. </p>
<p>Only relevant for multivalue hash tables.</p>
<p>Requires a CUDPPHandle for the hash table instance; call <a class="el" href="group__public_interface.html#ga0cd993f24223a9e5b59fc84bff5be22b" title="Creates a CUDPP hash table in GPU memory given an input hash table configuration; returns the plan fo...">cudppHashTable()</a> to get this handle.</p>
<p>See <a class="el" href="hash_overview.html">Overview of CUDPP hash tables</a> for an overview of CUDPP's hash table support.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Handle to hash table instance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_vals</td><td>Pointer to pointer of values (in GPU memory) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CUDPPResult indicating if operation was successful</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public_interface.html#ga0cd993f24223a9e5b59fc84bff5be22b" title="Creates a CUDPP hash table in GPU memory given an input hash table configuration; returns the plan fo...">cudppHashTable</a>, <a class="el" href="group__public_interface.html#gaab1189a6b1ce8ebb63c02ef46acd9595" title="Retrieves the size of the values array in a multivalue hash table. ">cudppMultivalueHashGetValuesSize</a>, <a class="el" href="hash_overview.html">Overview of CUDPP hash tables</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Nov 30 2016 15:29:13 for CUDPP by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
