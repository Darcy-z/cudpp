<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>CUDPP: CUDPP Kernel-Level API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUDPP
   &#160;<span id="projectnumber">2.3</span>
   </div>
   <div id="projectbrief">CUDA Data-Parallel Primitives Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CUDPP Kernel-Level API</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga70ad10920cae47887cda3b7f3b054663"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga70ad10920cae47887cda3b7f3b054663">alignedOffsets</a> (unsigned int *numSpaces, unsigned int *d_address, unsigned char *d_stringVals, unsigned char termC, unsigned int numElements, unsigned int stringSize)</td></tr>
<tr class="memdesc:ga70ad10920cae47887cda3b7f3b054663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the number of spaces required for each string to align the string array.  <a href="#ga70ad10920cae47887cda3b7f3b054663">More...</a><br /></td></tr>
<tr class="separator:ga70ad10920cae47887cda3b7f3b054663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga594b6e4c562178da2f9371ba419e6ec0"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga594b6e4c562178da2f9371ba419e6ec0">alignString</a> (unsigned int *packedStrings, unsigned char *d_stringVals, unsigned int *packedAddress, unsigned int *address, unsigned int numElements, unsigned int stringArrayLength, unsigned char termC)</td></tr>
<tr class="memdesc:ga594b6e4c562178da2f9371ba419e6ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packs strings into unsigned ints to be sorted later. These packed strings will also be aligned.  <a href="#ga594b6e4c562178da2f9371ba419e6ec0">More...</a><br /></td></tr>
<tr class="separator:ga594b6e4c562178da2f9371ba419e6ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffe16a1f50800b5e68d28595dda134fd"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gaffe16a1f50800b5e68d28595dda134fd">createKeys</a> (unsigned int *d_keys, unsigned int *packedStrings, unsigned int *packedAddress, unsigned int numElements)</td></tr>
<tr class="memdesc:gaffe16a1f50800b5e68d28595dda134fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create keys (first four characters stuffed in an uint) from the addresses to the strings, and the string array.  <a href="#gaffe16a1f50800b5e68d28595dda134fd">More...</a><br /></td></tr>
<tr class="separator:gaffe16a1f50800b5e68d28595dda134fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga689cbede029512b4cdc4978943161594"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga689cbede029512b4cdc4978943161594">unpackAddresses</a> (unsigned int *packedAddress, unsigned int *packedAddressRef, unsigned int *address, unsigned int *addressRef, size_t numElements)</td></tr>
<tr class="memdesc:ga689cbede029512b4cdc4978943161594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts addresses from packed (unaligned) form to unpacked and unaligned form Resulting aligned strings begin in our string array packed in an unsigned int and aligned such that each string begins at the start of a uint (divisible by 4)  <a href="#ga689cbede029512b4cdc4978943161594">More...</a><br /></td></tr>
<tr class="separator:ga689cbede029512b4cdc4978943161594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b3a522a516d07de956b9322fd705f2e"><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr class="memitem:ga0b3a522a516d07de956b9322fd705f2e"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga0b3a522a516d07de956b9322fd705f2e">blockWiseStringSort</a> (T *A_keys, T *A_address, T *stringVals, int blockSize, int totalSize, unsigned int stringSize, unsigned char termC)</td></tr>
<tr class="memdesc:ga0b3a522a516d07de956b9322fd705f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does an initial blockSort based on the size of our partition (limited by shared memory size)  <a href="#ga0b3a522a516d07de956b9322fd705f2e">More...</a><br /></td></tr>
<tr class="separator:ga0b3a522a516d07de956b9322fd705f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88d04c464169fdfd0fab7ca254008282"><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr class="memitem:ga88d04c464169fdfd0fab7ca254008282"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga88d04c464169fdfd0fab7ca254008282">simpleStringMerge</a> (T *A_keys, T *A_keys_out, T *A_values, T *A_values_out, T *stringValues, int sizePerPartition, int size, int step, int stringSize, unsigned char termC)</td></tr>
<tr class="memdesc:ga88d04c464169fdfd0fab7ca254008282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two independent sets. Each CUDA block works on two partitions of data without cooperating.  <a href="#ga88d04c464169fdfd0fab7ca254008282">More...</a><br /></td></tr>
<tr class="separator:ga88d04c464169fdfd0fab7ca254008282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b72611f4d03803fbdb455537140fac6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga4b72611f4d03803fbdb455537140fac6"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga4b72611f4d03803fbdb455537140fac6">findMultiPartitions</a> (T *A_keys, T *A_address, T *stringValues, int splitsPP, int numPartitions, int partitionSize, unsigned int *partitionBeginA, unsigned int *partitionSizesA, unsigned int *partitionBeginB, unsigned int *partitionSizesB, size_t size, size_t stringSize, unsigned char termC)</td></tr>
<tr class="memdesc:ga4b72611f4d03803fbdb455537140fac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For our multiMerge kernels we need to divide our partitions into smaller partitions. This kernel breaks up a set of partitions into splitsPP*numPartitions subpartitions.  <a href="#ga4b72611f4d03803fbdb455537140fac6">More...</a><br /></td></tr>
<tr class="separator:ga4b72611f4d03803fbdb455537140fac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d49363709d861ae8ff4468595144f0d"><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr class="memitem:ga3d49363709d861ae8ff4468595144f0d"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga3d49363709d861ae8ff4468595144f0d">stringMergeMulti</a> (T *A_keys, T *A_keys_out, T *A_values, T *A_values_out, T *stringValues, int subPartitions, int numBlocks, unsigned int *partitionBeginA, unsigned int *partitionSizeA, unsigned int *partitionBeginB, unsigned int *partitionSizeB, int entirePartitionSize, int step, size_t size, size_t stringSize, unsigned char termC)</td></tr>
<tr class="memdesc:ga3d49363709d861ae8ff4468595144f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main merge kernel where multiple CUDA blocks cooperate to merge a partition(s)  <a href="#ga3d49363709d861ae8ff4468595144f0d">More...</a><br /></td></tr>
<tr class="separator:ga3d49363709d861ae8ff4468595144f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Compact Functions</h2></td></tr>
<tr class="memitem:ga8bcff086bdbdc841344ac99fb7b15e97"><td class="memTemplParams" colspan="2">template&lt;class T , bool isBackward&gt; </td></tr>
<tr class="memitem:ga8bcff086bdbdc841344ac99fb7b15e97"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga8bcff086bdbdc841344ac99fb7b15e97">compactData</a> (T *d_out, size_t *d_numValidElements, const unsigned int *d_indices, const unsigned int *d_isValid, const T *d_in, unsigned int numElements)</td></tr>
<tr class="memdesc:ga8bcff086bdbdc841344ac99fb7b15e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consolidate non-null elements - for each non-null element in <em>d_in</em> write it to <em>d_out</em>, in the position specified by <em>d_isValid</em>. Called by <a class="el" href="group__cudpp__app.html#gad20b81b147eeecd6f2978e54a9eb3efb" title="Compact the non-zero elements of an array. ">compactArray()</a>.  <a href="#ga8bcff086bdbdc841344ac99fb7b15e97">More...</a><br /></td></tr>
<tr class="separator:ga8bcff086bdbdc841344ac99fb7b15e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Compress Functions</h2></td></tr>
<tr class="memitem:ga91ad9478d81a7aaf2593e8d9c3d06a14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga91ad9478d81a7aaf2593e8d9c3d06a14"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>uint</b></td></tr>
<tr class="separator:ga91ad9478d81a7aaf2593e8d9c3d06a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65f85814a8290f9797005d3b28e7e5fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga65f85814a8290f9797005d3b28e7e5fc"></a>
typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>uchar</b></td></tr>
<tr class="separator:ga65f85814a8290f9797005d3b28e7e5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab95f123a6c9bcfee6a343170ef8c5f69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab95f123a6c9bcfee6a343170ef8c5f69"></a>
typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><b>ushort</b></td></tr>
<tr class="separator:gab95f123a6c9bcfee6a343170ef8c5f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76ac9f96df0a5fc0f9e8c1fb3342224c"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga76ac9f96df0a5fc0f9e8c1fb3342224c">bwt_compute_final_kernel</a> (const uchar *d_bwtIn, const uint *d_values, int *d_bwtIndex, uchar *d_bwtOut, uint numElements, uint tThreads)</td></tr>
<tr class="memdesc:ga76ac9f96df0a5fc0f9e8c1fb3342224c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute final BWT.  <a href="#ga76ac9f96df0a5fc0f9e8c1fb3342224c">More...</a><br /></td></tr>
<tr class="separator:ga76ac9f96df0a5fc0f9e8c1fb3342224c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb034e3dde1a142044a3f0f9aa619f47"><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr class="memitem:gabb034e3dde1a142044a3f0f9aa619f47"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gabb034e3dde1a142044a3f0f9aa619f47">stringMergeMulti</a> (T *A_keys, T *A_keys_out, T *A_values, T *A_values_out, T *stringValues, int subPartitions, int numBlocks, int *partitionBeginA, int *partitionSizeA, int *partitionBeginB, int *partitionSizeB, int entirePartitionSize, size_t numElements)</td></tr>
<tr class="memdesc:gabb034e3dde1a142044a3f0f9aa619f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi merge.  <a href="#gabb034e3dde1a142044a3f0f9aa619f47">More...</a><br /></td></tr>
<tr class="separator:gabb034e3dde1a142044a3f0f9aa619f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37be91ad5990ef281cb6a32fa05450f1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga37be91ad5990ef281cb6a32fa05450f1"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga37be91ad5990ef281cb6a32fa05450f1">findMultiPartitions</a> (T *A, int splitsPP, int numPartitions, int partitionSize, int *partitionBeginA, int *partitionSizesA, int *partitionBeginB, int *partitionSizesB, int sizeA)</td></tr>
<tr class="memdesc:ga37be91ad5990ef281cb6a32fa05450f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges the indices for the "upper" block (right block)  <a href="#ga37be91ad5990ef281cb6a32fa05450f1">More...</a><br /></td></tr>
<tr class="separator:ga37be91ad5990ef281cb6a32fa05450f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58ad5608dd9bc2fe0283b3b67780903c"><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr class="memitem:ga58ad5608dd9bc2fe0283b3b67780903c"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga58ad5608dd9bc2fe0283b3b67780903c">simpleStringMerge</a> (T *A_keys, T *A_keys_out, T *A_values, T *A_values_out, T *stringValues, int sizePerPartition, int size, T *stringValues2, size_t numElements)</td></tr>
<tr class="memdesc:ga58ad5608dd9bc2fe0283b3b67780903c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple merge.  <a href="#ga58ad5608dd9bc2fe0283b3b67780903c">More...</a><br /></td></tr>
<tr class="separator:ga58ad5608dd9bc2fe0283b3b67780903c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5295254971430f95fef1ff069f3cb1d"><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr class="memitem:gaf5295254971430f95fef1ff069f3cb1d"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gaf5295254971430f95fef1ff069f3cb1d">blockWiseStringSort</a> (T *A_keys, T *A_address, const T *stringVals, T *stringVals2, int blockSize, size_t numElements)</td></tr>
<tr class="memdesc:gaf5295254971430f95fef1ff069f3cb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts blocks of data of size blockSize.  <a href="#gaf5295254971430f95fef1ff069f3cb1d">More...</a><br /></td></tr>
<tr class="separator:gaf5295254971430f95fef1ff069f3cb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d05a5c631bc48626934620fb72b3b39"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga9d05a5c631bc48626934620fb72b3b39">bwt_keys_construct_kernel</a> (uchar4 *d_bwtIn, uint *d_bwtInRef, uint *d_keys, uint *d_values, uint *d_bwtInRef2, uint tThreads)</td></tr>
<tr class="memdesc:ga9d05a5c631bc48626934620fb72b3b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Massage input to set up for merge sort.  <a href="#ga9d05a5c631bc48626934620fb72b3b39">More...</a><br /></td></tr>
<tr class="separator:ga9d05a5c631bc48626934620fb72b3b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d72d588b31baf58068a337d13bb603f"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga6d72d588b31baf58068a337d13bb603f">mtf_reduction_kernel</a> (const uchar *d_mtfIn, uchar *d_lists, ushort *d_list_sizes, uint nLists, uint offset, uint numElements)</td></tr>
<tr class="memdesc:ga6d72d588b31baf58068a337d13bb603f"><td class="mdescLeft">&#160;</td><td class="mdescRight">First stage in MTF (Reduction)  <a href="#ga6d72d588b31baf58068a337d13bb603f">More...</a><br /></td></tr>
<tr class="separator:ga6d72d588b31baf58068a337d13bb603f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9ee105a921c3c45a883904eaf1bbd8c"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gab9ee105a921c3c45a883904eaf1bbd8c">mtf_GLreduction_kernel</a> (uchar *d_lists, ushort *d_list_sizes, uint offset, uint tThreads, uint nLists)</td></tr>
<tr class="memdesc:gab9ee105a921c3c45a883904eaf1bbd8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Second stage in MTF (Global reduction)  <a href="#gab9ee105a921c3c45a883904eaf1bbd8c">More...</a><br /></td></tr>
<tr class="separator:gab9ee105a921c3c45a883904eaf1bbd8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga891303a3d2ac4bc37055100434f107d3"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga891303a3d2ac4bc37055100434f107d3">mtf_GLdownsweep_kernel</a> (uchar *d_lists, ushort *d_list_sizes, uint offset, uint lastLevel, uint nLists, uint tThreads)</td></tr>
<tr class="memdesc:ga891303a3d2ac4bc37055100434f107d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Third stage in MTF (Global downsweep)  <a href="#ga891303a3d2ac4bc37055100434f107d3">More...</a><br /></td></tr>
<tr class="separator:ga891303a3d2ac4bc37055100434f107d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40a79948a407885357d3abca1647fc6f"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga40a79948a407885357d3abca1647fc6f">mtf_localscan_lists_kernel</a> (const uchar *d_mtfIn, uchar *d_mtfOut, uchar *d_lists, ushort *d_list_sizes, uint nLists, uint offset, uint numElements)</td></tr>
<tr class="memdesc:ga40a79948a407885357d3abca1647fc6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute final MTF lists and final MTF output.  <a href="#ga40a79948a407885357d3abca1647fc6f">More...</a><br /></td></tr>
<tr class="separator:ga40a79948a407885357d3abca1647fc6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga094c75c96eb9efc8ecf1db4798a9cbc1"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga094c75c96eb9efc8ecf1db4798a9cbc1">huffman_build_histogram_kernel</a> (uint *d_input, uint *d_histograms, uint numElements)</td></tr>
<tr class="memdesc:ga094c75c96eb9efc8ecf1db4798a9cbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute 256-entry histogram.  <a href="#ga094c75c96eb9efc8ecf1db4798a9cbc1">More...</a><br /></td></tr>
<tr class="separator:ga094c75c96eb9efc8ecf1db4798a9cbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1749e7ec420d5fd99ef89b5fbe53b090"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1749e7ec420d5fd99ef89b5fbe53b090"></a>
__global__ void&#160;</td><td class="memItemRight" valign="bottom"><b>histo_kernel</b> (uchar *d_input, uint *d_histograms, uint numElements)</td></tr>
<tr class="separator:ga1749e7ec420d5fd99ef89b5fbe53b090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7aec2f652e5e46a5e138cc0f47b5e0a"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gac7aec2f652e5e46a5e138cc0f47b5e0a">huffman_build_tree_kernel</a> (const uchar *d_input, uchar *d_huffCodesPacked, uint *d_huffCodeLocations, uchar *d_huffCodeLengths, uint *d_histograms, uint *d_histogram, uint *d_nCodesPacked, uint *d_totalEncodedSize, uint histBlocks, uint numElements)</td></tr>
<tr class="memdesc:gac7aec2f652e5e46a5e138cc0f47b5e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build Huffman tree/codes.  <a href="#gac7aec2f652e5e46a5e138cc0f47b5e0a">More...</a><br /></td></tr>
<tr class="separator:gac7aec2f652e5e46a5e138cc0f47b5e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4196de63b3e83a8c85d93e352082c344"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga4196de63b3e83a8c85d93e352082c344">huffman_kernel_en</a> (uchar4 *d_input, uchar *d_codes, uint *d_code_locations, uchar *d_huffCodeLengths, encoded *d_encoded, uint nCodesPacked, uint nThreads)</td></tr>
<tr class="memdesc:ga4196de63b3e83a8c85d93e352082c344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform parallel Huffman encoding.  <a href="#ga4196de63b3e83a8c85d93e352082c344">More...</a><br /></td></tr>
<tr class="separator:ga4196de63b3e83a8c85d93e352082c344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bda5f1fc2b14ecde1f6e23a87cd0040"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga4bda5f1fc2b14ecde1f6e23a87cd0040">huffman_datapack_kernel</a> (encoded *d_encoded, uint *d_encodedData, uint *d_totalEncodedSize, uint *d_eOffsets)</td></tr>
<tr class="memdesc:ga4bda5f1fc2b14ecde1f6e23a87cd0040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack together encoded blocks.  <a href="#ga4bda5f1fc2b14ecde1f6e23a87cd0040">More...</a><br /></td></tr>
<tr class="separator:ga4bda5f1fc2b14ecde1f6e23a87cd0040"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
ListRank Functions</h2></td></tr>
<tr class="memitem:ga91ad9478d81a7aaf2593e8d9c3d06a14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga91ad9478d81a7aaf2593e8d9c3d06a14"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>uint</b></td></tr>
<tr class="separator:ga91ad9478d81a7aaf2593e8d9c3d06a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65f85814a8290f9797005d3b28e7e5fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga65f85814a8290f9797005d3b28e7e5fc"></a>
typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>uchar</b></td></tr>
<tr class="separator:ga65f85814a8290f9797005d3b28e7e5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab95f123a6c9bcfee6a343170ef8c5f69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab95f123a6c9bcfee6a343170ef8c5f69"></a>
typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><b>ushort</b></td></tr>
<tr class="separator:gab95f123a6c9bcfee6a343170ef8c5f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34378c8b582e8e7ccd8d72a1a1693b7d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga34378c8b582e8e7ccd8d72a1a1693b7d"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga34378c8b582e8e7ccd8d72a1a1693b7d">list_rank_kernel_soa_1</a> (T *d_ranked_values, const T *d_unranked_values, const int *d_ping, int *d_pong, int *d_start_indices, int step, int head, int numElts)</td></tr>
<tr class="memdesc:ga34378c8b582e8e7ccd8d72a1a1693b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use pointer jumping to rank values. After ranking the values, calculate the next set of indices. The number of values ranked doubles at each kernel call. Called by <a class="el" href="group__cudpp__app.html#ga01bedf77673d5b88ff3350b2da6517fa" title="Launch list ranking. ">listRank()</a>.  <a href="#ga34378c8b582e8e7ccd8d72a1a1693b7d">More...</a><br /></td></tr>
<tr class="separator:ga34378c8b582e8e7ccd8d72a1a1693b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae577209e82f356fb6c85f5e1fda95c12"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae577209e82f356fb6c85f5e1fda95c12"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gae577209e82f356fb6c85f5e1fda95c12">list_rank_kernel_soa_2</a> (T *d_ranked_values, const T *d_unranked_values, const int *d_pong, const int *d_start_indices, int head, int numElts)</td></tr>
<tr class="memdesc:gae577209e82f356fb6c85f5e1fda95c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">After pointer jumping is finished and all threads are able to rank values, ranking continues serially. Each thread ranks values until all values are ranked. Called by <a class="el" href="group__cudpp__app.html#ga01bedf77673d5b88ff3350b2da6517fa" title="Launch list ranking. ">listRank()</a>.  <a href="#gae577209e82f356fb6c85f5e1fda95c12">More...</a><br /></td></tr>
<tr class="separator:gae577209e82f356fb6c85f5e1fda95c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
MergeSort Functions</h2></td></tr>
<tr class="memitem:ga91ad9478d81a7aaf2593e8d9c3d06a14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga91ad9478d81a7aaf2593e8d9c3d06a14"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>uint</b></td></tr>
<tr class="separator:ga91ad9478d81a7aaf2593e8d9c3d06a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf61cef5da79e45f98f34e79c3c726680"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaf61cef5da79e45f98f34e79c3c726680"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gaf61cef5da79e45f98f34e79c3c726680">simpleCopy</a> (T *A_keys_dev, unsigned int *A_vals_dev, T *A_keys_out_dev, unsigned int *A_vals_out_dev, int offset, int numElementsToCopy)</td></tr>
<tr class="memdesc:gaf61cef5da79e45f98f34e79c3c726680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies unused portions of arrays in our ping-pong strategy.  <a href="#gaf61cef5da79e45f98f34e79c3c726680">More...</a><br /></td></tr>
<tr class="separator:gaf61cef5da79e45f98f34e79c3c726680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad030dd603515ec232ad9089f0a51c850"><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr class="memitem:gad030dd603515ec232ad9089f0a51c850"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gad030dd603515ec232ad9089f0a51c850">blockWiseSort</a> (T *A_keys, unsigned int *A_values, int blockSize, size_t totalSize)</td></tr>
<tr class="memdesc:gad030dd603515ec232ad9089f0a51c850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts blocks of data of size blockSize.  <a href="#gad030dd603515ec232ad9089f0a51c850">More...</a><br /></td></tr>
<tr class="separator:gad030dd603515ec232ad9089f0a51c850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61e7eb5fba3e08051dfc8fd98b26d10b"><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr class="memitem:ga61e7eb5fba3e08051dfc8fd98b26d10b"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga61e7eb5fba3e08051dfc8fd98b26d10b">simpleMerge_lower</a> (T *A_keys, unsigned int *A_values, T *A_keys_out, unsigned int *A_values_out, int sizePerPartition, int size)</td></tr>
<tr class="memdesc:ga61e7eb5fba3e08051dfc8fd98b26d10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges the indices for the "lower" block (left block)  <a href="#ga61e7eb5fba3e08051dfc8fd98b26d10b">More...</a><br /></td></tr>
<tr class="separator:ga61e7eb5fba3e08051dfc8fd98b26d10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e1c4ffc7f1bf77f525b84851b132d2d"><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr class="memitem:ga1e1c4ffc7f1bf77f525b84851b132d2d"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga1e1c4ffc7f1bf77f525b84851b132d2d">simpleMerge_higher</a> (T *A_keys, unsigned int *A_values, T *A_keys_out, unsigned int *A_values_out, int sizePerPartition, int size)</td></tr>
<tr class="memdesc:ga1e1c4ffc7f1bf77f525b84851b132d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges the indices for the "upper" block (right block)  <a href="#ga1e1c4ffc7f1bf77f525b84851b132d2d">More...</a><br /></td></tr>
<tr class="separator:ga1e1c4ffc7f1bf77f525b84851b132d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad74468b48ead6b4cd8d852b4d78de752"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gad74468b48ead6b4cd8d852b4d78de752"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gad74468b48ead6b4cd8d852b4d78de752">findMultiPartitions</a> (T *A, int splitsPP, int numPartitions, int partitionSize, int *partitionBeginA, int *partitionSizesA, int sizeA)</td></tr>
<tr class="memdesc:gad74468b48ead6b4cd8d852b4d78de752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges the indices for the "upper" block (right block)  <a href="#gad74468b48ead6b4cd8d852b4d78de752">More...</a><br /></td></tr>
<tr class="separator:gad74468b48ead6b4cd8d852b4d78de752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef796fffd411b210bd6e698d88bd3ba8"><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr class="memitem:gaef796fffd411b210bd6e698d88bd3ba8"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gaef796fffd411b210bd6e698d88bd3ba8">mergeMulti_lower</a> (T *A_keys_out, unsigned int *A_vals_out, T *A_keys, unsigned int *A_vals, int subPartitions, int numBlocks, int *partitionBeginA, int *partitionSizeA, int entirePartitionSize, int sizeA)</td></tr>
<tr class="memdesc:gaef796fffd411b210bd6e698d88bd3ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks cooperatively Merge two partitions for the indices in the "lower" block (left block)  <a href="#gaef796fffd411b210bd6e698d88bd3ba8">More...</a><br /></td></tr>
<tr class="separator:gaef796fffd411b210bd6e698d88bd3ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d1ca75184a9bfb0a988a5c2e990f668"><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr class="memitem:ga5d1ca75184a9bfb0a988a5c2e990f668"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga5d1ca75184a9bfb0a988a5c2e990f668">mergeMulti_higher</a> (T *A_keys_out, unsigned int *A_vals_out, T *A_keys, unsigned int *A_vals, int subPartitions, int numBlocks, int *partitionBeginA, int *partitionSizeA, int entirePartitionSize, int sizeA)</td></tr>
<tr class="memdesc:ga5d1ca75184a9bfb0a988a5c2e990f668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks cooperatively Merge two partitions for the indices in the "upper" block (right block)  <a href="#ga5d1ca75184a9bfb0a988a5c2e990f668">More...</a><br /></td></tr>
<tr class="separator:ga5d1ca75184a9bfb0a988a5c2e990f668"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Multisplit Functions</h2></td></tr>
<tr class="memitem:gaa009c1fd490d3fb6669daa3a79268fdf"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa009c1fd490d3fb6669daa3a79268fdf"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:gaa009c1fd490d3fb6669daa3a79268fdf"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>markBins_general</b> (uint *d_mark, uint *d_elements, uint numElements, uint numBuckets, T bucketMapper)</td></tr>
<tr class="separator:gaa009c1fd490d3fb6669daa3a79268fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9090fddc61dfb0caa1506c7ba1a27eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa9090fddc61dfb0caa1506c7ba1a27eb"></a>
__global__ void&#160;</td><td class="memItemRight" valign="bottom"><b>packingKeyValuePairs</b> (uint64 *packed, uint *input_key, uint *input_value, uint numElements)</td></tr>
<tr class="separator:gaa9090fddc61dfb0caa1506c7ba1a27eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6185c399a8b3a41f14352ef7cb41ed6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf6185c399a8b3a41f14352ef7cb41ed6"></a>
__global__ void&#160;</td><td class="memItemRight" valign="bottom"><b>unpackingKeyValuePairs</b> (uint64 *packed, uint *out_key, uint *out_value, uint numElements)</td></tr>
<tr class="separator:gaf6185c399a8b3a41f14352ef7cb41ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f20b171f17b8e2139d5d24e8fa742a0"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5f20b171f17b8e2139d5d24e8fa742a0"></a>
template&lt;uint32_t NUM_W, uint32_t DEPTH, typename bucket_t , typename key_t &gt; </td></tr>
<tr class="memitem:ga5f20b171f17b8e2139d5d24e8fa742a0"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>histogram_pre_scan_compaction</b> (key_t *input, uint32_t *bin, uint32_t numElements, bucket_t bucket_identifier)</td></tr>
<tr class="separator:ga5f20b171f17b8e2139d5d24e8fa742a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5518dd36a06b5b5e78666e331121904c"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5518dd36a06b5b5e78666e331121904c"></a>
template&lt;uint32_t NUM_W, uint32_t DEPTH, typename bucket_t , typename key_t &gt; </td></tr>
<tr class="memitem:ga5518dd36a06b5b5e78666e331121904c"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>split_post_scan_compaction</b> (key_t *key_input, uint32_t *warpOffsets, key_t *key_output, uint32_t numElements, bucket_t bucket_identifier)</td></tr>
<tr class="separator:ga5518dd36a06b5b5e78666e331121904c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6828ea177f1ca3c05aee671dc110f2f6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga6828ea177f1ca3c05aee671dc110f2f6"></a>
template&lt;uint32_t NUM_W, uint32_t DEPTH, typename bucket_t , typename key_t , typename value_t &gt; </td></tr>
<tr class="memitem:ga6828ea177f1ca3c05aee671dc110f2f6"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>split_post_scan_pairs_compaction</b> (key_t *key_input, value_t *value_input, uint32_t *warpOffsets, key_t *key_output, value_t *value_output, uint32_t numElements, bucket_t bucket_identifier)</td></tr>
<tr class="separator:ga6828ea177f1ca3c05aee671dc110f2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga160f923c820560c234bb05e18df6e78b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga160f923c820560c234bb05e18df6e78b"></a>
template&lt;uint32_t NUM_W, uint32_t NUM_B, uint32_t LOG_B, uint32_t DEPTH, typename bucket_t , typename key_type &gt; </td></tr>
<tr class="memitem:ga160f923c820560c234bb05e18df6e78b"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multisplit_WMS_prescan</b> (key_type *input, uint32_t *bin, uint32_t numElements, bucket_t bucket_identifier)</td></tr>
<tr class="separator:ga160f923c820560c234bb05e18df6e78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf78e80f9b88bb763b14a9b904027d01f"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf78e80f9b88bb763b14a9b904027d01f"></a>
template&lt;uint32_t NUM_W, uint32_t NUM_B, uint32_t LOG_B, uint32_t DEPTH, typename bucket_t , typename key_type &gt; </td></tr>
<tr class="memitem:gaf78e80f9b88bb763b14a9b904027d01f"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multisplit_WMS_postscan</b> (key_type *key_input, uint32_t *warpOffsets, key_type *key_output, uint32_t numElements, bucket_t bucket_identifier)</td></tr>
<tr class="separator:gaf78e80f9b88bb763b14a9b904027d01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1258a0c06993715208d9ae1a66b95ec1"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1258a0c06993715208d9ae1a66b95ec1"></a>
template&lt;uint32_t NUM_W, uint32_t NUM_B, uint32_t LOG_B, uint32_t DEPTH, typename bucket_t , typename key_type , typename value_type &gt; </td></tr>
<tr class="memitem:ga1258a0c06993715208d9ae1a66b95ec1"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multisplit_WMS_pairs_postscan</b> (key_type *key_input, value_type *value_input, uint32_t *warpOffsets, key_type *key_output, value_type *value_output, uint32_t numElements, bucket_t bucket_identifier)</td></tr>
<tr class="separator:ga1258a0c06993715208d9ae1a66b95ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4091af70c0332af236b5af7ebfcc33f2"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga4091af70c0332af236b5af7ebfcc33f2"></a>
template&lt;uint32_t NUM_W, uint32_t LOG_W, uint32_t NUM_B, uint32_t LOG_B, uint32_t DEPTH, typename bucket_t , typename key_type &gt; </td></tr>
<tr class="memitem:ga4091af70c0332af236b5af7ebfcc33f2"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multisplit_BMS_prescan</b> (key_type *input, uint32_t *bin, uint32_t numElements, bucket_t bucket_identifier)</td></tr>
<tr class="separator:ga4091af70c0332af236b5af7ebfcc33f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99e7bff8b0c377013978b6083ecf92ea"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga99e7bff8b0c377013978b6083ecf92ea"></a>
template&lt;uint32_t NUM_W, uint32_t LOG_W, uint32_t NUM_B, uint32_t LOG_B, uint32_t DEPTH, typename bucket_t , typename key_type &gt; </td></tr>
<tr class="memitem:ga99e7bff8b0c377013978b6083ecf92ea"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multisplit_BMS_postscan</b> (key_type *key_input, uint32_t *blockOffsets, key_type *key_output, uint32_t numElements, bucket_t bucket_identifier)</td></tr>
<tr class="separator:ga99e7bff8b0c377013978b6083ecf92ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e9691227f5eab8bba6b1fd4822d1c93"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1e9691227f5eab8bba6b1fd4822d1c93"></a>
template&lt;uint32_t NUM_W, uint32_t LOG_W, uint32_t NUM_B, uint32_t LOG_B, uint32_t DEPTH, typename bucket_t , typename key_type , typename value_type &gt; </td></tr>
<tr class="memitem:ga1e9691227f5eab8bba6b1fd4822d1c93"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multisplit_BMS_pairs_postscan</b> (key_type *key_input, value_type *value_input, uint32_t *blockOffsets, key_type *key_output, value_type *value_output, uint32_t numElements, bucket_t bucket_identifier)</td></tr>
<tr class="separator:ga1e9691227f5eab8bba6b1fd4822d1c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
RadixSort Functions</h2></td></tr>
<tr class="memitem:ga91ad9478d81a7aaf2593e8d9c3d06a14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga91ad9478d81a7aaf2593e8d9c3d06a14"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>uint</b></td></tr>
<tr class="separator:ga91ad9478d81a7aaf2593e8d9c3d06a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9b2c50ca94fbb436128f97475148d84"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad9b2c50ca94fbb436128f97475148d84"></a>
__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gad9b2c50ca94fbb436128f97475148d84">emptyKernel</a> ()</td></tr>
<tr class="memdesc:gad9b2c50ca94fbb436128f97475148d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">And empty kernel used to reset CTA issue hardware. <br /></td></tr>
<tr class="separator:gad9b2c50ca94fbb436128f97475148d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa002e725192c3ac452f6c3168de2895a"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gaa002e725192c3ac452f6c3168de2895a">flipFloats</a> (uint *values, uint numValues)</td></tr>
<tr class="memdesc:gaa002e725192c3ac452f6c3168de2895a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does special binary arithmetic before sorting floats.  <a href="#gaa002e725192c3ac452f6c3168de2895a">More...</a><br /></td></tr>
<tr class="separator:gaa002e725192c3ac452f6c3168de2895a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga359f23566212946fc94d7a61c9e4dfd3"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga359f23566212946fc94d7a61c9e4dfd3">unflipFloats</a> (uint *values, uint numValues)</td></tr>
<tr class="memdesc:ga359f23566212946fc94d7a61c9e4dfd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undoes the flips from flipFloats.  <a href="#ga359f23566212946fc94d7a61c9e4dfd3">More...</a><br /></td></tr>
<tr class="separator:ga359f23566212946fc94d7a61c9e4dfd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54245e088cb6d521a47a13babdb3169a"><td class="memTemplParams" colspan="2">template&lt;bool flip&gt; </td></tr>
<tr class="memitem:ga54245e088cb6d521a47a13babdb3169a"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga54245e088cb6d521a47a13babdb3169a">radixSortSingleWarp</a> (uint *keys, uint *values, uint numElements)</td></tr>
<tr class="memdesc:ga54245e088cb6d521a47a13babdb3169a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimization for sorts of WARP_SIZE or fewer elements.  <a href="#ga54245e088cb6d521a47a13babdb3169a">More...</a><br /></td></tr>
<tr class="separator:ga54245e088cb6d521a47a13babdb3169a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecf76fb813cd5ec6db206db8c58da431"><td class="memTemplParams" colspan="2">template&lt;bool flip&gt; </td></tr>
<tr class="memitem:gaecf76fb813cd5ec6db206db8c58da431"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gaecf76fb813cd5ec6db206db8c58da431">radixSortSingleWarpKeysOnly</a> (uint *keys, uint numElements)</td></tr>
<tr class="memdesc:gaecf76fb813cd5ec6db206db8c58da431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimization for sorts of WARP_SIZE or fewer elements. Keys-Only version.  <a href="#gaecf76fb813cd5ec6db206db8c58da431">More...</a><br /></td></tr>
<tr class="separator:gaecf76fb813cd5ec6db206db8c58da431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8beab509166183f4bfa87f541bdf3287"><td class="memTemplParams" colspan="2">template&lt;uint nbits, uint startbit, bool fullBlocks, bool flip, bool loop&gt; </td></tr>
<tr class="memitem:ga8beab509166183f4bfa87f541bdf3287"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga8beab509166183f4bfa87f541bdf3287">radixSortBlocks</a> (uint4 *keysOut, uint4 *valuesOut, uint4 *keysIn, uint4 *valuesIn, uint numElements, uint totalBlocks)</td></tr>
<tr class="memdesc:ga8beab509166183f4bfa87f541bdf3287"><td class="mdescLeft">&#160;</td><td class="mdescRight">sorts all blocks of data independently in shared memory. Each thread block (CTA) sorts one block of 4*CTA_SIZE elements  <a href="#ga8beab509166183f4bfa87f541bdf3287">More...</a><br /></td></tr>
<tr class="separator:ga8beab509166183f4bfa87f541bdf3287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc9fa78a2c80a2025923df1d7901b96c"><td class="memTemplParams" colspan="2">template&lt;uint startbit, bool fullBlocks, bool loop&gt; </td></tr>
<tr class="memitem:gabc9fa78a2c80a2025923df1d7901b96c"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gabc9fa78a2c80a2025923df1d7901b96c">findRadixOffsets</a> (uint2 *keys, uint *counters, uint *blockOffsets, uint numElements, uint totalBlocks)</td></tr>
<tr class="memdesc:gabc9fa78a2c80a2025923df1d7901b96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of keys of each radix in each block stores offset.  <a href="#gabc9fa78a2c80a2025923df1d7901b96c">More...</a><br /></td></tr>
<tr class="separator:gabc9fa78a2c80a2025923df1d7901b96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc885d87d0c8788ee4075f1b986b46b2"><td class="memTemplParams" colspan="2">template&lt;uint startbit, bool fullBlocks, bool manualCoalesce, bool unflip, bool loop&gt; </td></tr>
<tr class="memitem:gadc885d87d0c8788ee4075f1b986b46b2"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gadc885d87d0c8788ee4075f1b986b46b2">reorderData</a> (uint *outKeys, uint *outValues, uint2 *keys, uint2 *values, uint *blockOffsets, uint *offsets, uint *sizes, uint numElements, uint totalBlocks)</td></tr>
<tr class="memdesc:gadc885d87d0c8788ee4075f1b986b46b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders data in the global array.  <a href="#gadc885d87d0c8788ee4075f1b986b46b2">More...</a><br /></td></tr>
<tr class="separator:gadc885d87d0c8788ee4075f1b986b46b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad39fb537d4823a5dada002d0437d5264"><td class="memTemplParams" colspan="2">template&lt;uint nbits, uint startbit, bool fullBlocks, bool flip, bool loop&gt; </td></tr>
<tr class="memitem:gad39fb537d4823a5dada002d0437d5264"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gad39fb537d4823a5dada002d0437d5264">radixSortBlocksKeysOnly</a> (uint4 *keysOut, uint4 *keysIn, uint numElements, uint totalBlocks)</td></tr>
<tr class="memdesc:gad39fb537d4823a5dada002d0437d5264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts all blocks of data independently in shared memory. Each thread block (CTA) sorts one block of 4*CTA_SIZE elements.  <a href="#gad39fb537d4823a5dada002d0437d5264">More...</a><br /></td></tr>
<tr class="separator:gad39fb537d4823a5dada002d0437d5264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf53e3b863c610dc0c435f3cebc3ab20"><td class="memTemplParams" colspan="2">template&lt;uint startbit, bool fullBlocks, bool manualCoalesce, bool unflip, bool loop&gt; </td></tr>
<tr class="memitem:gacf53e3b863c610dc0c435f3cebc3ab20"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gacf53e3b863c610dc0c435f3cebc3ab20">reorderDataKeysOnly</a> (uint *outKeys, uint2 *keys, uint *blockOffsets, uint *offsets, uint *sizes, uint numElements, uint totalBlocks)</td></tr>
<tr class="memdesc:gacf53e3b863c610dc0c435f3cebc3ab20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders data in the global array.  <a href="#gacf53e3b863c610dc0c435f3cebc3ab20">More...</a><br /></td></tr>
<tr class="separator:gacf53e3b863c610dc0c435f3cebc3ab20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Rand Functions</h2></td></tr>
<tr class="memitem:gaa69e40f48791d63cdd66d101a22f6a4a"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gaa69e40f48791d63cdd66d101a22f6a4a">gen_randMD5</a> (uint4 *d_out, size_t numElements, unsigned int seed)</td></tr>
<tr class="memdesc:gaa69e40f48791d63cdd66d101a22f6a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main MD5 generation algorithm.  <a href="#gaa69e40f48791d63cdd66d101a22f6a4a">More...</a><br /></td></tr>
<tr class="separator:gaa69e40f48791d63cdd66d101a22f6a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Reduce Functions</h2></td></tr>
<tr class="memitem:ga7521c98ae7bbc0143ddc7bb1ddf94677"><td class="memTemplParams" colspan="2">template&lt;typename T , class Oper , unsigned int blockSize, bool nIsPow2&gt; </td></tr>
<tr class="memitem:ga7521c98ae7bbc0143ddc7bb1ddf94677"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga7521c98ae7bbc0143ddc7bb1ddf94677">reduce</a> (T *odata, const T *idata, unsigned int n)</td></tr>
<tr class="memdesc:ga7521c98ae7bbc0143ddc7bb1ddf94677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main reduction kernel.  <a href="#ga7521c98ae7bbc0143ddc7bb1ddf94677">More...</a><br /></td></tr>
<tr class="separator:ga7521c98ae7bbc0143ddc7bb1ddf94677"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Suffix Array Functions</h2></td></tr>
<tr class="memitem:ga91ad9478d81a7aaf2593e8d9c3d06a14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga91ad9478d81a7aaf2593e8d9c3d06a14"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>uint</b></td></tr>
<tr class="separator:ga91ad9478d81a7aaf2593e8d9c3d06a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65f85814a8290f9797005d3b28e7e5fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga65f85814a8290f9797005d3b28e7e5fc"></a>
typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>uchar</b></td></tr>
<tr class="separator:ga65f85814a8290f9797005d3b28e7e5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7d8bee27abc89ba76be80fea6aff6a1"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gaa7d8bee27abc89ba76be80fea6aff6a1">strConstruct</a> (uchar *d_str, uint *d_str_value, size_t str_length)</td></tr>
<tr class="memdesc:gaa7d8bee27abc89ba76be80fea6aff6a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the input array.  <a href="#gaa7d8bee27abc89ba76be80fea6aff6a1">More...</a><br /></td></tr>
<tr class="separator:gaa7d8bee27abc89ba76be80fea6aff6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24a005917a832e7751be9a08d0ec620d"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga24a005917a832e7751be9a08d0ec620d">resultConstruct</a> (uint *d_keys_sa, size_t str_length)</td></tr>
<tr class="memdesc:ga24a005917a832e7751be9a08d0ec620d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstruct the output.  <a href="#ga24a005917a832e7751be9a08d0ec620d">More...</a><br /></td></tr>
<tr class="separator:ga24a005917a832e7751be9a08d0ec620d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d86e2d29a6a4151237c0b2bc675a66d"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga1d86e2d29a6a4151237c0b2bc675a66d">sa12_keys_construct</a> (uint *d_str, uint *d_keys_uint_12, uint *d_keys_srt_12, int mod_1, size_t tThreads)</td></tr>
<tr class="memdesc:ga1d86e2d29a6a4151237c0b2bc675a66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the SA12 triplets.  <a href="#ga1d86e2d29a6a4151237c0b2bc675a66d">More...</a><br /></td></tr>
<tr class="separator:ga1d86e2d29a6a4151237c0b2bc675a66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e1cae48ea200b1d3a9cdb4f2ed2cfd5"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga6e1cae48ea200b1d3a9cdb4f2ed2cfd5">sa12_keys_construct_0</a> (uint *d_str, uint *d_keys_uint_12, uint *d_keys_srt_12, size_t tThreads)</td></tr>
<tr class="memdesc:ga6e1cae48ea200b1d3a9cdb4f2ed2cfd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct SA12 for the second radix sort.  <a href="#ga6e1cae48ea200b1d3a9cdb4f2ed2cfd5">More...</a><br /></td></tr>
<tr class="separator:ga6e1cae48ea200b1d3a9cdb4f2ed2cfd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b5b432636e093d618b90f5fe9007271"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga7b5b432636e093d618b90f5fe9007271">sa12_keys_construct_1</a> (uint *d_str, uint *d_keys_uint_12, uint *d_keys_srt_12, size_t tThreads)</td></tr>
<tr class="memdesc:ga7b5b432636e093d618b90f5fe9007271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct SA12 for the third radix sort.  <a href="#ga7b5b432636e093d618b90f5fe9007271">More...</a><br /></td></tr>
<tr class="separator:ga7b5b432636e093d618b90f5fe9007271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafad8fca9e66a9eca535791da632ce3b9"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gafad8fca9e66a9eca535791da632ce3b9">compute_rank</a> (uint *d_str, uint *d_keys_srt_12, uint *d_flag, bool *result, size_t tThreads, int str_length)</td></tr>
<tr class="memdesc:gafad8fca9e66a9eca535791da632ce3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on flags for sorted SA12 triplets.  <a href="#gafad8fca9e66a9eca535791da632ce3b9">More...</a><br /></td></tr>
<tr class="separator:gafad8fca9e66a9eca535791da632ce3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ee3264371612d83a6db6fda95de1da1"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga7ee3264371612d83a6db6fda95de1da1">new_str_construct</a> (uint *d_new_str, uint *d_keys_srt_12, uint *d_rank, int mod_1, size_t tThreads)</td></tr>
<tr class="memdesc:ga7ee3264371612d83a6db6fda95de1da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct new array for recursion.  <a href="#ga7ee3264371612d83a6db6fda95de1da1">More...</a><br /></td></tr>
<tr class="separator:ga7ee3264371612d83a6db6fda95de1da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga908b4cab9ace22afa7529465f2cb6283"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga908b4cab9ace22afa7529465f2cb6283">reconstruct</a> (uint *d_keys_srt_12, uint *d_isa_12, uint *d_flag, int mod_1, size_t tThreads)</td></tr>
<tr class="memdesc:ga908b4cab9ace22afa7529465f2cb6283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate SA12 from recursion.  <a href="#ga908b4cab9ace22afa7529465f2cb6283">More...</a><br /></td></tr>
<tr class="separator:ga908b4cab9ace22afa7529465f2cb6283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba00e43c7c81987c51d519be4b4ef8ca"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gaba00e43c7c81987c51d519be4b4ef8ca">isa12_construct</a> (uint *d_keys_srt_12, uint *d_isa_12, uint *d_flag, int mod_1, size_t tThreads)</td></tr>
<tr class="memdesc:gaba00e43c7c81987c51d519be4b4ef8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct ISA12.  <a href="#gaba00e43c7c81987c51d519be4b4ef8ca">More...</a><br /></td></tr>
<tr class="separator:gaba00e43c7c81987c51d519be4b4ef8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8185cdc6a51ac267f0e026eb08847ec7"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga8185cdc6a51ac267f0e026eb08847ec7">sa3_srt_construct</a> (uint *d_keys_srt_3, uint *d_str, uint *d_keys_srt_12, uint *d_keys_sa, size_t tThreads1, size_t tThreads2, int str_length)</td></tr>
<tr class="memdesc:ga8185cdc6a51ac267f0e026eb08847ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contruct SA3 triplets positions.  <a href="#ga8185cdc6a51ac267f0e026eb08847ec7">More...</a><br /></td></tr>
<tr class="separator:ga8185cdc6a51ac267f0e026eb08847ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9276d2e295af98016a48819ebd711338"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga9276d2e295af98016a48819ebd711338">sa3_keys_construct</a> (uint *d_keys_srt_3, uint *d_keys_sa, uint *d_str, size_t tThreads, int str_length)</td></tr>
<tr class="memdesc:ga9276d2e295af98016a48819ebd711338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct SA3 triplets keys.  <a href="#ga9276d2e295af98016a48819ebd711338">More...</a><br /></td></tr>
<tr class="separator:ga9276d2e295af98016a48819ebd711338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb5fd670a36678010959f4c3353d36c9"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gacb5fd670a36678010959f4c3353d36c9">merge_akeys_construct</a> (uint *d_str, uint *d_keys_srt_12, uint *d_isa_12, Vector *d_aKeys, size_t tThreads, int mod_1, int bound, int str_length)</td></tr>
<tr class="memdesc:gacb5fd670a36678010959f4c3353d36c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct SA12 keys in terms of Vector.  <a href="#gacb5fd670a36678010959f4c3353d36c9">More...</a><br /></td></tr>
<tr class="separator:gacb5fd670a36678010959f4c3353d36c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacab33e3a955d976a4b70aa0f5300f338"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gacab33e3a955d976a4b70aa0f5300f338">merge_bkeys_construct</a> (uint *d_str, uint *d_keys_srt_3, uint *d_isa_12, Vector *d_bKeys, size_t tThreads, int mod_1, int bound, int str_length)</td></tr>
<tr class="memdesc:gacab33e3a955d976a4b70aa0f5300f338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct SA3 keys in Vector.  <a href="#gacab33e3a955d976a4b70aa0f5300f338">More...</a><br /></td></tr>
<tr class="separator:gacab33e3a955d976a4b70aa0f5300f338"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Scan Functions</h2></td></tr>
<tr class="memitem:ga5a9326c2008d8299ef7e73eaec36199d"><td class="memTemplParams" colspan="2">template&lt;class T , class traits &gt; </td></tr>
<tr class="memitem:ga5a9326c2008d8299ef7e73eaec36199d"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga5a9326c2008d8299ef7e73eaec36199d">scan4</a> (T *d_out, const T *d_in, T *d_blockSums, int numElements, unsigned int dataRowPitch, unsigned int blockSumRowPitch)</td></tr>
<tr class="memdesc:ga5a9326c2008d8299ef7e73eaec36199d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main scan kernel.  <a href="#ga5a9326c2008d8299ef7e73eaec36199d">More...</a><br /></td></tr>
<tr class="separator:ga5a9326c2008d8299ef7e73eaec36199d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Segmented scan Functions</h2></td></tr>
<tr class="memitem:ga8038b6964e23b2c8a7440caab529a53d"><td class="memTemplParams" colspan="2">template&lt;class T , class traits &gt; </td></tr>
<tr class="memitem:ga8038b6964e23b2c8a7440caab529a53d"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga8038b6964e23b2c8a7440caab529a53d">segmentedScan4</a> (T *d_odata, const T *d_idata, const unsigned int *d_iflags, unsigned int numElements, T *d_blockSums=0, unsigned int *d_blockFlags=0, unsigned int *d_blockIndices=0)</td></tr>
<tr class="memdesc:ga8038b6964e23b2c8a7440caab529a53d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main segmented scan kernel.  <a href="#ga8038b6964e23b2c8a7440caab529a53d">More...</a><br /></td></tr>
<tr class="separator:ga8038b6964e23b2c8a7440caab529a53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Sparse Matrix-Vector multiply Functions</h2></td></tr>
<tr class="memitem:gafe1f2573c8c6a1c3f46a23b4e8a8bedb"><td class="memTemplParams" colspan="2">template&lt;class T , bool isFullBlock&gt; </td></tr>
<tr class="memitem:gafe1f2573c8c6a1c3f46a23b4e8a8bedb"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gafe1f2573c8c6a1c3f46a23b4e8a8bedb">sparseMatrixVectorFetchAndMultiply</a> (unsigned int *d_flags, T *d_prod, const T *d_A, const T *d_x, const unsigned int *d_indx, unsigned int numNZElts)</td></tr>
<tr class="memdesc:gafe1f2573c8c6a1c3f46a23b4e8a8bedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch and multiply kernel.  <a href="#gafe1f2573c8c6a1c3f46a23b4e8a8bedb">More...</a><br /></td></tr>
<tr class="separator:gafe1f2573c8c6a1c3f46a23b4e8a8bedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga650782aef0e14c36782f5c24cd96a8dd"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga650782aef0e14c36782f5c24cd96a8dd">sparseMatrixVectorSetFlags</a> (unsigned int *d_flags, const unsigned int *d_rowindx, unsigned int numRows)</td></tr>
<tr class="memdesc:ga650782aef0e14c36782f5c24cd96a8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Flags kernel.  <a href="#ga650782aef0e14c36782f5c24cd96a8dd">More...</a><br /></td></tr>
<tr class="separator:ga650782aef0e14c36782f5c24cd96a8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ed96c2a55daf3050462ef744a6afb89"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga9ed96c2a55daf3050462ef744a6afb89"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga9ed96c2a55daf3050462ef744a6afb89">yGather</a> (T *d_y, const T *d_prod, const unsigned int *d_rowFindx, unsigned int numRows)</td></tr>
<tr class="memdesc:ga9ed96c2a55daf3050462ef744a6afb89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather final y values kernel.  <a href="#ga9ed96c2a55daf3050462ef744a6afb89">More...</a><br /></td></tr>
<tr class="separator:ga9ed96c2a55daf3050462ef744a6afb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Tridiagonal functions</h2></td></tr>
<tr class="memitem:ga41a45d3864bf92579aec2abcdf0cbe3e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga41a45d3864bf92579aec2abcdf0cbe3e"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga41a45d3864bf92579aec2abcdf0cbe3e">crpcrKernel</a> (T *d_a, T *d_b, T *d_c, T *d_d, T *d_x, unsigned int systemSizeOriginal, unsigned int iterations)</td></tr>
<tr class="memdesc:ga41a45d3864bf92579aec2abcdf0cbe3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hybrid CR-PCR Tridiagonal linear system solver (CRPCR)  <a href="#ga41a45d3864bf92579aec2abcdf0cbe3e">More...</a><br /></td></tr>
<tr class="separator:ga41a45d3864bf92579aec2abcdf0cbe3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Vector Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp63f22eef98a4e7ae7df3cf1d55988889"></a>CUDA kernel methods for basic operations on vectors. </p>
</td></tr>
<tr class="memitem:ga8c8f5547a1f502329282cc95429740d1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga8c8f5547a1f502329282cc95429740d1"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga8c8f5547a1f502329282cc95429740d1">vectorAddConstant</a> (T *d_vector, T constant, int n, int baseIndex)</td></tr>
<tr class="memdesc:ga8c8f5547a1f502329282cc95429740d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant value to all values in the input d_vector.  <a href="#ga8c8f5547a1f502329282cc95429740d1">More...</a><br /></td></tr>
<tr class="separator:ga8c8f5547a1f502329282cc95429740d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24917914ea67043dbf8163f9e2add37f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga24917914ea67043dbf8163f9e2add37f"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga24917914ea67043dbf8163f9e2add37f">vectorAddUniform</a> (T *d_vector, const T *d_uniforms, int numElements, int blockOffset, int baseIndex)</td></tr>
<tr class="memdesc:ga24917914ea67043dbf8163f9e2add37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a uniform value to each data element of an array.  <a href="#ga24917914ea67043dbf8163f9e2add37f">More...</a><br /></td></tr>
<tr class="separator:ga24917914ea67043dbf8163f9e2add37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad44685e2b1a696a07e18ab8aaa926f71"><td class="memTemplParams" colspan="2"><a class="anchor" id="gad44685e2b1a696a07e18ab8aaa926f71"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad44685e2b1a696a07e18ab8aaa926f71"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vectorAddUniform2</b> (T *g_data, T *uniforms, int n, int eltsPerBlock)</td></tr>
<tr class="separator:gad44685e2b1a696a07e18ab8aaa926f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1863374854d2c073002707ba6032fbd9"><td class="memTemplParams" colspan="2">template&lt;class T , class Oper , int elementsPerThread, bool fullBlocks&gt; </td></tr>
<tr class="memitem:ga1863374854d2c073002707ba6032fbd9"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga1863374854d2c073002707ba6032fbd9">vectorAddUniform4</a> (T *d_vector, const T *d_uniforms, int numElements, int vectorRowPitch, int uniformRowPitch, int blockOffset, int baseIndex)</td></tr>
<tr class="memdesc:ga1863374854d2c073002707ba6032fbd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a uniform value to each data element of an array (vec4 version)  <a href="#ga1863374854d2c073002707ba6032fbd9">More...</a><br /></td></tr>
<tr class="separator:ga1863374854d2c073002707ba6032fbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09b902a5ab815491eb7cd6fa52a127d0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga09b902a5ab815491eb7cd6fa52a127d0"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga09b902a5ab815491eb7cd6fa52a127d0">vectorAddVector</a> (T *d_vectorA, const T *d_vectorB, int numElements, int baseIndex)</td></tr>
<tr class="memdesc:ga09b902a5ab815491eb7cd6fa52a127d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds together two vectors.  <a href="#ga09b902a5ab815491eb7cd6fa52a127d0">More...</a><br /></td></tr>
<tr class="separator:ga09b902a5ab815491eb7cd6fa52a127d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3918c5ba5af7670e6a7d3fbeb9bf575b"><td class="memTemplParams" colspan="2">template&lt;class T , class Oper , bool isLastBlockFull&gt; </td></tr>
<tr class="memitem:ga3918c5ba5af7670e6a7d3fbeb9bf575b"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga3918c5ba5af7670e6a7d3fbeb9bf575b">vectorSegmentedAddUniform4</a> (T *d_vector, const T *d_uniforms, const unsigned int *d_maxIndices, unsigned int numElements, int blockOffset, int baseIndex)</td></tr>
<tr class="memdesc:ga3918c5ba5af7670e6a7d3fbeb9bf575b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a uniform value to data elements of an array (vec4 version)  <a href="#ga3918c5ba5af7670e6a7d3fbeb9bf575b">More...</a><br /></td></tr>
<tr class="separator:ga3918c5ba5af7670e6a7d3fbeb9bf575b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f54ac578b08ad752c5771bce9115084"><td class="memTemplParams" colspan="2">template&lt;class T , class Oper , bool isLastBlockFull&gt; </td></tr>
<tr class="memitem:ga2f54ac578b08ad752c5771bce9115084"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga2f54ac578b08ad752c5771bce9115084">vectorSegmentedAddUniformToRight4</a> (T *d_vector, const T *d_uniforms, const unsigned int *d_minIndices, unsigned int numElements, int blockOffset, int baseIndex)</td></tr>
<tr class="memdesc:ga2f54ac578b08ad752c5771bce9115084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a uniform value to data elements of an array (vec4 version)  <a href="#ga2f54ac578b08ad752c5771bce9115084">More...</a><br /></td></tr>
<tr class="separator:ga2f54ac578b08ad752c5771bce9115084"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The CUDPP Kernel-Level API contains functions that run on the GPU device across a grid of Cooperative Thread Array (CTA, aka Thread Block). These kernels are declared <code><b>global</b></code> so that they must be invoked from host (CPU) code. They generally invoke GPU <code><b>device</b></code> routines in the CUDPP <a class="el" href="group__cudpp__cta.html">CTA-Level API</a>. Kernel-Level API functions are used by CUDPP <a class="el" href="group__cudpp__app.html">Application-Level</a> functions to implement their functionality. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga8bcff086bdbdc841344ac99fb7b15e97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool isBackward&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void compactData </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>d_numValidElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_isValid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consolidate non-null elements - for each non-null element in <em>d_in</em> write it to <em>d_out</em>, in the position specified by <em>d_isValid</em>. Called by <a class="el" href="group__cudpp__app.html#gad20b81b147eeecd6f2978e54a9eb3efb" title="Compact the non-zero elements of an array. ">compactArray()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>Output array of compacted values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_numValidElements</td><td>The number of elements in d_in with valid flags set to 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_indices</td><td>Positions where non-null elements will go in d_out. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_isValid</td><td>Flags indicating valid (1) and invalid (0) elements. Only valid elements will be copied to <em>d_out</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>The input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The length of the <em>d_in</em> in elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga76ac9f96df0a5fc0f9e8c1fb3342224c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void bwt_compute_final_kernel </td>
          <td>(</td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>d_bwtIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint *&#160;</td>
          <td class="paramname"><em>d_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>d_bwtIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>d_bwtOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>tThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute final BWT. </p>
<p>This is the final stage in the BWT. This stage computes the final values of the BWT output. It is given the indices of where each of the cyclical rotations of the initial input were sorted to. It uses these indices to figure out the last "column" of the sorted cyclical rotations which is the final BWT output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_bwtIn</td><td>Input char array to perform the BWT on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_values</td><td>Input array that gives the indices of where each of the cyclical rotations of the intial input were sorted to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_bwtIndex</td><td>Output pointer to store the BWT index. The index tells us where the original string sorted to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_bwtOut</td><td>Output char array of the BWT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements we are performing a BWT on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tThreads</td><td>The total threads we have dispatched on the device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabb034e3dde1a142044a3f0f9aa619f47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void stringMergeMulti </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_values_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>stringValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subPartitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numBlocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionBeginA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionSizeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionBeginB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionSizeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>entirePartitionSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multi merge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A_keys</td><td>keys to be sorted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_keys_out</td><td>keys after being sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_values</td><td>associated values to keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_values_out</td><td>associated values after sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringValues</td><td>keys of each of the cyclical rotations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subPartitions</td><td>Number of blocks working on a partition (number of sub-partitions) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numBlocks</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">partitionBeginA</td><td>Where each partition/subpartition will begin in A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitionSizeA</td><td>Partition sizes decided by function findMultiPartitions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">partitionBeginB</td><td>Where each partition/subpartition will begin in B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitionSizeB</td><td>Partition sizes decided by function findMultiPartitions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entirePartitionSize</td><td>The size of an entire partition (before it is split up) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Size of the enitre array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga37be91ad5990ef281cb6a32fa05450f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void findMultiPartitions </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>splitsPP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numPartitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>partitionSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionBeginA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionSizesA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionBeginB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionSizesB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges the indices for the "upper" block (right block) </p>
<p>Utilizes a "ping-pong" strategy </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Global array of keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splitsPP</td><td>Global array of values to be merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numPartitions</td><td>number of partitions being considered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitionSize</td><td>Size of each partition being considered </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">partitionBeginA</td><td>Where each partition/subpartition will begin in A </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">partitionSizesA</td><td>Size of each partition/subpartition in A </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">partitionBeginB</td><td>Where each partition/subpartition will begin in B </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">partitionSizesB</td><td>Size of each partition/subpartition in B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizeA</td><td>Size of the entire array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga58ad5608dd9bc2fe0283b3b67780903c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void simpleStringMerge </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_values_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>stringValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizePerPartition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>stringValues2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple merge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A_keys</td><td>keys to be sorted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_keys_out</td><td>keys after being sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_values</td><td>associated values to keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_values_out</td><td>associated values after sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringValues</td><td>BWT string manipulated to words </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizePerPartition</td><td>Size of each partition being merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of total Array being sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringValues2</td><td>keys of each of the cyclical rotations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements being sorted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf5295254971430f95fef1ff069f3cb1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void blockWiseStringSort </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>stringVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>stringVals2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts blocks of data of size blockSize. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A_keys</td><td>keys to be sorted </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A_address</td><td>associated values to keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringVals</td><td>BWT string manipulated to words </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringVals2</td><td>keys of each of the cyclical rotations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockSize</td><td>Size of the chunks being sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Size of the enitre array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9d05a5c631bc48626934620fb72b3b39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void bwt_keys_construct_kernel </td>
          <td>(</td>
          <td class="paramtype">uchar4 *&#160;</td>
          <td class="paramname"><em>d_bwtIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_bwtInRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_bwtInRef2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>tThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Massage input to set up for merge sort. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_bwtIn</td><td>A char array of the input data stream to perform the BWT on. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_bwtInRef</td><td>BWT string manipulated to words. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys</td><td>An array of associated keys to sort by the first four chars of the cyclical rotations. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_values</td><td>Array of values associates with the keys to sort. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_bwtInRef2</td><td>keys of each of the cyclical rotations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tThreads</td><td>Pointer to the plan object used for this BWT. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6d72d588b31baf58068a337d13bb603f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void mtf_reduction_kernel </td>
          <td>(</td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>d_mtfIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>d_lists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort *&#160;</td>
          <td class="paramname"><em>d_list_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nLists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>First stage in MTF (Reduction) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_mtfIn</td><td>A char array of the input data stream to perform the MTF on. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_lists</td><td>A pointer to the start of MTF lists. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_list_sizes</td><td>An array storing the size of each MTF list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nLists</td><td>Total number of MTF lists. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset during the reduction stage. Initialized to two. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of input elements MTF transform. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab9ee105a921c3c45a883904eaf1bbd8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void mtf_GLreduction_kernel </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>d_lists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort *&#160;</td>
          <td class="paramname"><em>d_list_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>tThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nLists</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Second stage in MTF (Global reduction) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_lists</td><td>A pointer to the start of MTF lists. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_list_sizes</td><td>An array storing the size of each MTF list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset during the reduction stage. Initialized to two. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tThreads</td><td>Total number of threads dispatched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nLists</td><td>Total number of MTF lists. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga891303a3d2ac4bc37055100434f107d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void mtf_GLdownsweep_kernel </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>d_lists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort *&#160;</td>
          <td class="paramname"><em>d_list_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>lastLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nLists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>tThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Third stage in MTF (Global downsweep) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_lists</td><td>A pointer to the start of MTF lists. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_list_sizes</td><td>An array storing the size of each MTF list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset during the reduction stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lastLevel</td><td>The limit to which offset can be set to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nLists</td><td>Total number of MTF lists. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tThreads</td><td>Total number of threads dispatched. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga40a79948a407885357d3abca1647fc6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void mtf_localscan_lists_kernel </td>
          <td>(</td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>d_mtfIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>d_mtfOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>d_lists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort *&#160;</td>
          <td class="paramname"><em>d_list_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nLists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute final MTF lists and final MTF output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_mtfIn</td><td>A char array of the input data stream to perform the MTF on. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_mtfOut</td><td>A char array of the output with the transformed MTF string. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_lists</td><td>A pointer to the start of MTF lists. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_list_sizes</td><td>An array storing the size of each MTF list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nLists</td><td>Total number of MTF lists. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset during the reduction stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of elements to perform the MTF on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga094c75c96eb9efc8ecf1db4798a9cbc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void huffman_build_histogram_kernel </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_histograms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute 256-entry histogram. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_input</td><td>An array of words we will use to build our histogram. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_histograms</td><td>A pointer where we store our global histograms. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The total number of elements to build our histogram from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac7aec2f652e5e46a5e138cc0f47b5e0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void huffman_build_tree_kernel </td>
          <td>(</td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>d_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>d_huffCodesPacked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_huffCodeLocations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>d_huffCodeLengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_histograms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_histogram</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_nCodesPacked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_totalEncodedSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>histBlocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build Huffman tree/codes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_input</td><td>An array of input elements to encode </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_huffCodesPacked</td><td>An array of huffman bit codes packed together </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_huffCodeLocations</td><td>An array which stores the starting bit locations of each Huffman bit code </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_huffCodeLengths</td><td>An array which stores the lengths of each Huffman bit code </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_histograms</td><td>An input array of histograms to combine </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_histogram</td><td>Final histogram combined </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_nCodesPacked</td><td>Number of chars it took to store all Huffman bit codes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_totalEncodedSize</td><td>Total number of words it takes to hold the compressed data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">histBlocks</td><td>Total number of histograms we will combine into one </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements to compress </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4196de63b3e83a8c85d93e352082c344"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void huffman_kernel_en </td>
          <td>(</td>
          <td class="paramtype">uchar4 *&#160;</td>
          <td class="paramname"><em>d_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>d_codes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_code_locations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>d_huffCodeLengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">encoded *&#160;</td>
          <td class="paramname"><em>d_encoded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nCodesPacked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform parallel Huffman encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_input</td><td>Input array to encode </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_codes</td><td>Array of packed Huffman bit codes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_code_locations</td><td>Array of starting Huffman bit locations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_huffCodeLengths</td><td>An array storing the bit lengths of the Huffman codes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_encoded</td><td>An array of encoded classes which stores the size and data of encoded data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nCodesPacked</td><td>Number of chars it took to store all Huffman bit codes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nThreads</td><td>Total number of dispatched threads </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4bda5f1fc2b14ecde1f6e23a87cd0040"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void huffman_datapack_kernel </td>
          <td>(</td>
          <td class="paramtype">encoded *&#160;</td>
          <td class="paramname"><em>d_encoded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_encodedData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_totalEncodedSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_eOffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack together encoded blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_encoded</td><td>An array of encoded objects with stored size and data of the encoded data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_encodedData</td><td>An in array to store all encoded data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_totalEncodedSize</td><td>Total number words of the encoded data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_eOffsets</td><td>Array holding the word offsets of each encoded data block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga34378c8b582e8e7ccd8d72a1a1693b7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void list_rank_kernel_soa_1 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_ranked_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_unranked_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>d_ping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>d_pong</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>d_start_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use pointer jumping to rank values. After ranking the values, calculate the next set of indices. The number of values ranked doubles at each kernel call. Called by <a class="el" href="group__cudpp__app.html#ga01bedf77673d5b88ff3350b2da6517fa" title="Launch list ranking. ">listRank()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_ranked_values</td><td>Ranked values array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_unranked_values</td><td>Unranked values array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_ping</td><td>Next indices array for the current kernel call </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_pong</td><td>Next indices array for the next kernel call </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_start_indices</td><td>Holds the starting node indices for "ranking" threads. The number of "ranking" threads doubles at each stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step</td><td>The number of "ranking" threads. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">head</td><td>Head node index of the linked-list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElts</td><td>Number of nodes to rank </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae577209e82f356fb6c85f5e1fda95c12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void list_rank_kernel_soa_2 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_ranked_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_unranked_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>d_pong</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>d_start_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>After pointer jumping is finished and all threads are able to rank values, ranking continues serially. Each thread ranks values until all values are ranked. Called by <a class="el" href="group__cudpp__app.html#ga01bedf77673d5b88ff3350b2da6517fa" title="Launch list ranking. ">listRank()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_ranked_values</td><td>Ranked values array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_unranked_values</td><td>Unranked values array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_pong</td><td>Next indices array for the current kernel call </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_start_indices</td><td>Holds the starting node indices for "ranking" threads. The number of "ranking" threads doubles at each stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">head</td><td>Head node index of the linked-list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElts</td><td>Number of nodes to rank </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf61cef5da79e45f98f34e79c3c726680"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void simpleCopy </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>A_vals_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys_out_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>A_vals_out_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElementsToCopy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies unused portions of arrays in our ping-pong strategy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A_keys_dev,A_vals_dev</td><td>The keys and values we will be copying </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_keys_out_dev,A_vals_out_dev</td><td>The keys and values array we will copy to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset we are starting to copy from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElementsToCopy</td><td>The number of elements we copy starting from the offset</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_keys_dev</td><td>The keys we will be copying </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_vals_dev</td><td>The values we will be copying </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_keys_out_dev</td><td>The destination keys array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_vals_out_dev</td><td>The destination values array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset we are starting to copy from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElementsToCopy</td><td>The number of elements we copy starting from the offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad030dd603515ec232ad9089f0a51c850"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void blockWiseSort </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>A_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>totalSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts blocks of data of size blockSize. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A_keys</td><td>keys to be sorted </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A_values</td><td>associated values to keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockSize</td><td>Size of the chunks being sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">totalSize</td><td>Size of the enitre array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga61e7eb5fba3e08051dfc8fd98b26d10b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void simpleMerge_lower </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>A_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>A_values_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizePerPartition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges the indices for the "lower" block (left block) </p>
<p>Utilizes a "ping-pong" strategy </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A_keys</td><td>Global array of keys to be merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_values</td><td>Global array of values to be merged </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_keys_out</td><td>Resulting array of keys merged </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_values_out</td><td>Resulting array of values merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizePerPartition</td><td>Size of each partition being merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of total Array being sorted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1e1c4ffc7f1bf77f525b84851b132d2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void simpleMerge_higher </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>A_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>A_values_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizePerPartition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges the indices for the "upper" block (right block) </p>
<p>Utilizes a "ping-pong" strategy </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A_keys</td><td>Global array of keys to be merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_values</td><td>Global array of values to be merged </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_keys_out</td><td>Resulting array of keys merged </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_values_out</td><td>Resulting array of values merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizePerPartition</td><td>Size of each partition being merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of total Array being sorted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad74468b48ead6b4cd8d852b4d78de752"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void findMultiPartitions </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>splitsPP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numPartitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>partitionSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionBeginA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionSizesA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges the indices for the "upper" block (right block) </p>
<p>Utilizes a "ping-pong" strategy </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Global array of keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splitsPP</td><td>Global array of values to be merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numPartitions</td><td>number of partitions being considered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitionSize</td><td>Size of each partition being considered </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">partitionBeginA</td><td>Where each partition/subpartition will begin in A </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">partitionSizesA</td><td>Size of each partition/subpartition in A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizeA</td><td>Size of the entire array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaef796fffd411b210bd6e698d88bd3ba8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void mergeMulti_lower </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>A_vals_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>A_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subPartitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numBlocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionBeginA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionSizeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>entirePartitionSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks cooperatively Merge two partitions for the indices in the "lower" block (left block) </p>
<p>Utilizes a "ping-pong" strategy </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">A_keys_out</td><td>Resulting array of keys merged </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_vals_out</td><td>Resulting array of values merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_keys</td><td>Global array of keys to be merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_vals</td><td>Global array of values to be merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subPartitions</td><td>Number of blocks working on a partition (number of sub-partitions) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numBlocks</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitionBeginA</td><td>Partition starting points decided by function findMultiPartitions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitionSizeA</td><td>Partition sizes decided by function findMultiPartitions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entirePartitionSize</td><td>The size of an entire partition (before it is split up) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizeA</td><td>The total size of our array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5d1ca75184a9bfb0a988a5c2e990f668"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void mergeMulti_higher </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>A_vals_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>A_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subPartitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numBlocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionBeginA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionSizeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>entirePartitionSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks cooperatively Merge two partitions for the indices in the "upper" block (right block) </p>
<p>Utilizes a "ping-pong" strategy </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">A_keys_out</td><td>Resulting array of keys merged </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_vals_out</td><td>Resulting array of values merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_keys</td><td>Global array of keys to be merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_vals</td><td>Global array of values to be merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subPartitions</td><td>Number of blocks working on a partition (number of sub-partitions) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numBlocks</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitionBeginA</td><td>Partition starting points decided by function findMultiPartitions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitionSizeA</td><td>Partition sizes decided by function findMultiPartitions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entirePartitionSize</td><td>The size of an entire partition (before it is split up) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizeA</td><td>The total size of our array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa002e725192c3ac452f6c3168de2895a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void flipFloats </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does special binary arithmetic before sorting floats. </p>
<p>Uses floatFlip function to flip bits. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Values to be manipulated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numValues</td><td>Number of values to be flipped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga359f23566212946fc94d7a61c9e4dfd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void unflipFloats </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undoes the flips from flipFloats. </p>
<p>Uses floatUnflip function to unflip bits. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Values to be manipulated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numValues</td><td>Number of values to be unflipped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga54245e088cb6d521a47a13babdb3169a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool flip&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void radixSortSingleWarp </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimization for sorts of WARP_SIZE or fewer elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Associated values to be sorted (through keys). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaecf76fb813cd5ec6db206db8c58da431"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool flip&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void radixSortSingleWarpKeysOnly </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimization for sorts of WARP_SIZE or fewer elements. Keys-Only version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of elements to be sorted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8beab509166183f4bfa87f541bdf3287"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint nbits, uint startbit, bool fullBlocks, bool flip, bool loop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void radixSortBlocks </td>
          <td>(</td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>keysOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>valuesOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>keysIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>valuesIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>totalBlocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sorts all blocks of data independently in shared memory. Each thread block (CTA) sorts one block of 4*CTA_SIZE elements </p>
<p>The radix sort is done in two stages. This stage calls radixSortBlock on each block independently, sorting on the basis of bits (startbit) -&gt; (startbit + nbits)</p>
<p>Template parameters are used to generate efficient code for various special cases For example, we have to handle arrays that are a multiple of the block size (fullBlocks) differently than arrays that are not. "flip" is used to only compile in the float flip code when float keys are used. "loop" is used when persistent CTAs are used.</p>
<p>By persistent CTAs we mean that we launch only as many thread blocks as can be resident in the GPU and no more, rather than launching as many threads as we have elements. Persistent CTAs loop over blocks of elements until all work is complete. This can be faster in some cases. In our tests it is faster for large sorts (and the threshold is higher on compute version 1.1 and earlier GPUs than it is on compute version 1.2 GPUs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">keysOut</td><td>Output of sorted keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">valuesOut</td><td>Output of associated values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keysIn</td><td>Input of unsorted keys in GPU </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valuesIn</td><td>Input of associated input values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of elements to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">totalBlocks</td><td>The number of blocks of data to sort </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabc9fa78a2c80a2025923df1d7901b96c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint startbit, bool fullBlocks, bool loop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void findRadixOffsets </td>
          <td>(</td>
          <td class="paramtype">uint2 *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>counters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>blockOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>totalBlocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the number of keys of each radix in each block stores offset. </p>
<p>Given an array with blocks sorted according to a 4-bit radix group, each block counts the number of keys that fall into each radix in the group, and finds the starting offset of each radix in the block. It then writes the radix counts to the counters array, and the starting offsets to the blockOffsets array.</p>
<p>Template parameters are used to generate efficient code for various special cases For example, we have to handle arrays that are a multiple of the block size (fullBlocks) differently than arrays that are not. "loop" is used when persistent CTAs are used.</p>
<p>By persistent CTAs we mean that we launch only as many thread blocks as can be resident in the GPU and no more, rather than launching as many threads as we have elements. Persistent CTAs loop over blocks of elements until all work is complete. This can be faster in some cases. In our tests it is faster for large sorts (and the threshold is higher on compute version 1.1 and earlier GPUs than it is on compute version 1.2 GPUs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>Input keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counters</td><td>Radix count for each block </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">blockOffsets</td><td>The offset address for each block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">totalBlocks</td><td>Total number of blocks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadc885d87d0c8788ee4075f1b986b46b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint startbit, bool fullBlocks, bool manualCoalesce, bool unflip, bool loop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void reorderData </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>outKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>outValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint2 *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint2 *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>blockOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>totalBlocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorders data in the global array. </p>
<p>reorderData shuffles data in the array globally after the radix offsets have been found. On compute version 1.1 and earlier GPUs, this code depends on SORT_CTA_SIZE being 16 * number of radices (i.e. 16 * 2^nbits).</p>
<p>On compute version 1.1 GPUs ("manualCoalesce=true") this function ensures that all writes are coalesced using extra work in the kernel. On later GPUs coalescing rules have been relaxed, so this extra overhead hurts performance. On these GPUs we set manualCoalesce=false and directly store the results.</p>
<p>Template parameters are used to generate efficient code for various special cases For example, we have to handle arrays that are a multiple of the block size (fullBlocks) differently than arrays that are not. "loop" is used when persistent CTAs are used.</p>
<p>By persistent CTAs we mean that we launch only as many thread blocks as can be resident in the GPU and no more, rather than launching as many threads as we have elements. Persistent CTAs loop over blocks of elements until all work is complete. This can be faster in some cases. In our tests it is faster for large sorts (and the threshold is higher on compute version 1.1 and earlier GPUs than it is on compute version 1.2 GPUs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outKeys</td><td>Output of sorted keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outValues</td><td>Output of associated values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>Input of unsorted keys in GPU </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Input of associated input values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockOffsets</td><td>The offset address for each block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>Address of each radix within each block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizes</td><td>Number of elements in a block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">totalBlocks</td><td>Total number of data blocks to process</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>Args that are const below should be prototyped as const </dd></dl>

</div>
</div>
<a class="anchor" id="gad39fb537d4823a5dada002d0437d5264"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint nbits, uint startbit, bool fullBlocks, bool flip, bool loop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void radixSortBlocksKeysOnly </td>
          <td>(</td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>keysOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>keysIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>totalBlocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts all blocks of data independently in shared memory. Each thread block (CTA) sorts one block of 4*CTA_SIZE elements. </p>
<p>The radix sort is done in two stages. This stage calls radixSortBlock on each block independently, sorting on the basis of bits (startbit) -&gt; (startbit + nbits)</p>
<p>Template parameters are used to generate efficient code for various special cases For example, we have to handle arrays that are a multiple of the block size (fullBlocks) differently than arrays that are not. "flip" is used to only compile in the float flip code when float keys are used. "loop" is used when persistent CTAs are used.</p>
<p>By persistent CTAs we mean that we launch only as many thread blocks as can be resident in the GPU and no more, rather than launching as many threads as we have elements. Persistent CTAs loop over blocks of elements until all work is complete. This can be faster in some cases. In our tests it is faster for large sorts (and the threshold is higher on compute version 1.1 and earlier GPUs than it is on compute version 1.2 GPUs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">keysOut</td><td>Output of sorted keys GPU main memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keysIn</td><td>Input of unsorted keys in GPU main memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of elements to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">totalBlocks</td><td>Total number of blocks to sort </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacf53e3b863c610dc0c435f3cebc3ab20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint startbit, bool fullBlocks, bool manualCoalesce, bool unflip, bool loop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void reorderDataKeysOnly </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>outKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint2 *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>blockOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>totalBlocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorders data in the global array. </p>
<p>reorderDataKeysOnly shuffles data in the array globally after the radix offsets have been found. On compute version 1.1 and earlier GPUs, this code depends on SORT_CTA_SIZE being 16 * number of radices (i.e. 16 * 2^nbits).</p>
<p>On compute version 1.1 GPUs ("manualCoalesce=true") this function ensures that all writes are coalesced using extra work in the kernel. On later GPUs coalescing rules have been relaxed, so this extra overhead hurts performance. On these GPUs we set manualCoalesce=false and directly store the results.</p>
<p>Template parameters are used to generate efficient code for various special cases For example, we have to handle arrays that are a multiple of the block size (fullBlocks) differently than arrays that are not. "loop" is used when persistent CTAs are used.</p>
<p>By persistent CTAs we mean that we launch only as many thread blocks as can be resident in the GPU and no more, rather than launching as many threads as we have elements. Persistent CTAs loop over blocks of elements until all work is complete. This can be faster in some cases. In our tests it is faster for large sorts (and the threshold is higher on compute version 1.1 and earlier GPUs than it is on compute version 1.2 GPUs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outKeys</td><td>Output result of <a class="el" href="group__cudpp__kernel.html#gacf53e3b863c610dc0c435f3cebc3ab20" title="Reorders data in the global array. ">reorderDataKeysOnly()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>Keys to be reordered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockOffsets</td><td>Start offset for each block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>Offset of each radix within each block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizes</td><td>Number of elements in a block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">totalBlocks</td><td>Total number of blocks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa69e40f48791d63cdd66d101a22f6a4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void gen_randMD5 </td>
          <td>(</td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The main MD5 generation algorithm. </p>
<p>This function runs the MD5 hashing random number generator. It generates MD5 hashes, and uses the output as randomized bits. To repeatedly call this function, always call <a class="el" href="group__public_interface.html#ga9120af9942d2553d2f376ede0f7079dd" title="Sets the seed used for rand. ">cudppRandSeed()</a> first to set a new seed or else the output may be the same due to the deterministic nature of hashes. gen_randMD5 generates 128 random bits per thread. Therefore, the parameter <em>d_out</em> is expected to be an array of type uint4 with <em>numElements</em> indicies.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>the output array of type uint4. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>the number of elements in <em>d_out</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>the random seed used to vary the output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rand__app_8cu.html#aa6aa7195d99a4d1c79c444b95b1d2a92" title="Launches the MD5 Random number generator kernel. ">launchRandMD5Kernel()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7521c98ae7bbc0143ddc7bb1ddf94677"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Oper , unsigned int blockSize, bool nIsPow2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void reduce </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>odata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>idata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main reduction kernel. </p>
<p>This reduction kernel adds multiple elements per thread sequentially, and then the threads work together to produce a block sum in shared memory. The code is optimized using warp-synchronous programming to eliminate unnecessary barrier synchronization. Performing sequential work in each thread before performing the log(N) parallel summation reduces the overall cost of the algorithm while keeping the work complexity O(n) and the step complexity O(log n). (Brent's Theorem optimization)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">odata</td><td>The output data pointer. Each block writes a single output element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idata</td><td>The input data pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of elements to be reduced. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa7d8bee27abc89ba76be80fea6aff6a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void strConstruct </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>d_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_str_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>str_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the input array. </p>
<p>This is the first stage in the SA. This stage construct the input array composed of values of the input char array followed by three 0s.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_str</td><td>Input char array to perform the SA on. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_str_value</td><td>Output unsigned int array prepared for SA. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str_length</td><td>The number of elements we are performing the SA on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga24a005917a832e7751be9a08d0ec620d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void resultConstruct </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_keys_sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>str_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reconstruct the output. </p>
<p>This is the final stage in the SA. This stage reconstruct the output array by reducing each value by one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_keys_sa</td><td>Final output of the suffix array which stores the positions of sorted suffixes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str_length</td><td>Size of the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1d86e2d29a6a4151237c0b2bc675a66d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void sa12_keys_construct </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_keys_uint_12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_keys_srt_12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mod_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the SA12 triplets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_str</td><td>Initial array of character values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_uint_12</td><td>The keys of righ-most char in SA12 triplets. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_srt_12</td><td>SA12 triplets positions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mod_1</td><td>The number of elements whose positions mod3 = 1 (SA1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tThreads</td><td>The number of elements whose positions mod3 = 1,2 (SA12) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6e1cae48ea200b1d3a9cdb4f2ed2cfd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void sa12_keys_construct_0 </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_keys_uint_12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_keys_srt_12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct SA12 for the second radix sort. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_str</td><td>Initial array of character values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_uint_12</td><td>The keys of second char in SA12 triplets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_srt_12</td><td>SA12 triplets positions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tThreads</td><td>The number of elements in SA12. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7b5b432636e093d618b90f5fe9007271"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void sa12_keys_construct_1 </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_keys_uint_12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_keys_srt_12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct SA12 for the third radix sort. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_str</td><td>Initial array of character values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_uint_12</td><td>The keys of third char in SA12 triplets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_srt_12</td><td>SA12 triplets positions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tThreads</td><td>The number of elements in SA12. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafad8fca9e66a9eca535791da632ce3b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void compute_rank </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_keys_srt_12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>str_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn on flags for sorted SA12 triplets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_str</td><td>Initial array of character values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_srt_12</td><td>SA12 triplets positions. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_flag</td><td>Marking the sorted triplets. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>0 if SA12 is not fully sorted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tThreads</td><td>The number of elements in SA12. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str_length</td><td>The number of elements in original string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7ee3264371612d83a6db6fda95de1da1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void new_str_construct </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_new_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_keys_srt_12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mod_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct new array for recursion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_new_str</td><td>The new string to be sent to recursion. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_srt_12</td><td>SA12 triplets positions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_rank</td><td>Ranks of SA12 from compute_rank kernel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mod_1</td><td>The number of elements of SA1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tThreads</td><td>The number of elements of SA12. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga908b4cab9ace22afa7529465f2cb6283"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void reconstruct </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_keys_srt_12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_isa_12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mod_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate SA12 from recursion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_keys_srt_12</td><td>Sorted SA12. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_isa_12</td><td>ISA12. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_flag</td><td>Flags to mark SA1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mod_1</td><td>The number of elements in SA1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tThreads</td><td>The number of elements in SA12. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaba00e43c7c81987c51d519be4b4ef8ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void isa12_construct </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_keys_srt_12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_isa_12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mod_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct ISA12. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_srt_12</td><td>Fully sorted SA12 in global position. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_isa_12</td><td>ISA12 to store the ranks in local position. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_flag</td><td>Flags to mark SA1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mod_1</td><td>The number of elements in SA1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tThreads</td><td>The number of elements in SA12. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8185cdc6a51ac267f0e026eb08847ec7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void sa3_srt_construct </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_keys_srt_3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_keys_srt_12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_keys_sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tThreads1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tThreads2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>str_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contruct SA3 triplets positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_srt_3</td><td>SA3 generated from SA1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_str</td><td>Original input array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_srt_12</td><td>Fully sorted SA12. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_sa</td><td>Positions of SA1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tThreads1</td><td>The number of elements of SA12. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tThreads2</td><td>The number of elements of SA3. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str_length</td><td>The number of elements in original string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9276d2e295af98016a48819ebd711338"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void sa3_keys_construct </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_keys_srt_3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_keys_sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>str_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct SA3 triplets keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_srt_3</td><td>SA3 triplets positions. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_sa</td><td>SA3 keys. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_str</td><td>Original input string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tThreads</td><td>The number of elements in SA12. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str_length</td><td>The number of elements in original string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacb5fd670a36678010959f4c3353d36c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void merge_akeys_construct </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_keys_srt_12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_isa_12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector *&#160;</td>
          <td class="paramname"><em>d_aKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mod_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>str_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct SA12 keys in terms of Vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_str</td><td>Original input data stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_srt_12</td><td>The order of aKeys. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_isa_12</td><td>The ranks in SA12 orders. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_aKeys</td><td>SA12 keys in Vectors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tThreads</td><td>The number elements in SA12 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mod_1</td><td>The number of elements in SA1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bound</td><td>The number of elements in SA12 plus SA3. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str_length</td><td>The number of elements in original string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacab33e3a955d976a4b70aa0f5300f338"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void merge_bkeys_construct </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_keys_srt_3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_isa_12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector *&#160;</td>
          <td class="paramname"><em>d_bKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mod_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>str_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct SA3 keys in Vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_str</td><td>Original input data stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_srt_3</td><td>The order of bKeys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_isa_12</td><td>ISA12. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_bKeys</td><td>SA3 keys in Vectors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tThreads</td><td>The number of total threads. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mod_1</td><td>The number of elements in SA1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bound</td><td>The number of elements in SA12 and SA3. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str_length</td><td>The number of elements in original str. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5a9326c2008d8299ef7e73eaec36199d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void scan4 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_blockSums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dataRowPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>blockSumRowPitch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main scan kernel. </p>
<p>This <b>global</b> device function performs one level of a multiblock scan on an arbitrary-dimensioned array in <em>d_in</em>, returning the result in <em>d_out</em> (which may point to the same array). The same function may be used for single or multi-row scans. To perform a multirow scan, pass the width of each row of the input row (in elements) in <em>dataRowPitch</em>, and the width of the rows of <em>d_blockSums</em> (in elements) in <em>blockSumRowPitch</em>, and invoke with a thread block grid with height greater than 1.</p>
<p>This function peforms one level of a recursive, multiblock scan. At the app level, this function is called by cudppScan and cudppMultiScan and used in combination with <a class="el" href="group__cudpp__kernel.html#ga1863374854d2c073002707ba6032fbd9" title="Add a uniform value to each data element of an array (vec4 version) ">vectorAddUniform4()</a> to produce a complete scan.</p>
<p>Template parameter <em>T</em> is the datatype of the array to be scanned. Template parameter <em>traits</em> is the <a class="el" href="class_scan_traits.html" title="Template class containing compile-time parameters to the scan functions. ">ScanTraits</a> struct containing compile-time options for the scan, such as whether it is forward or backward, exclusive or inclusive, multi- or single-row, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>The output (scanned) array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>The input array to be scanned </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_blockSums</td><td>The array of per-block sums </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataRowPitch</td><td>The width of each row of <em>d_in</em> in elements (for multi-row scans) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockSumRowPitch</td><td>The with of each row of <em>d_blockSums</em> in elements (for multi-row scans) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8038b6964e23b2c8a7440caab529a53d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void segmentedScan4 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_odata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_idata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_iflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_blockSums</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_blockFlags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_blockIndices</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main segmented scan kernel. </p>
<p>This <b>global</b> device function performs one level of a multiblock segmented scan on an one-dimensioned array in <em>d_idata</em>, returning the result in <em>d_odata</em> (which may point to the same array).</p>
<p>This function performs one level of a recursive, multiblock scan. At the app level, this function is called by cudppSegmentedScan and used in combination with either <a class="el" href="group__cudpp__kernel.html#ga3918c5ba5af7670e6a7d3fbeb9bf575b" title="Add a uniform value to data elements of an array (vec4 version) ">vectorSegmentedAddUniform4()</a> (forward) or <a class="el" href="group__cudpp__kernel.html#ga2f54ac578b08ad752c5771bce9115084" title="Add a uniform value to data elements of an array (vec4 version) ">vectorSegmentedAddUniformToRight4()</a> (backward) to produce a complete segmented scan.</p>
<p>Template parameter <em>T</em> is the datatype of the array to be scanned. Template parameter <em>traits</em> is the <a class="el" href="class_segmented_scan_traits.html" title="Template class containing compile-time parameters to the segmented scan functions. ">SegmentedScanTraits</a> struct containing compile-time options for the segmented scan, such as whether it is forward or backward, inclusive or exclusive, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_odata</td><td>The output (scanned) array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_idata</td><td>The input array to be scanned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_iflags</td><td>The input array of flags </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_blockSums</td><td>The array of per-block sums </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_blockFlags</td><td>The array of per-block OR-reduction of flags </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_blockIndices</td><td>The array of per-block min-reduction of indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements to scan </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafe1f2573c8c6a1c3f46a23b4e8a8bedb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool isFullBlock&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void sparseMatrixVectorFetchAndMultiply </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_prod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numNZElts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch and multiply kernel. </p>
<p>This <b>global</b> device function takes an element from the vector d_A, finds its column in d_indx and multiplies the element from d_A with its corresponding (that is having the same row) element in d_x and stores the resulting product in d_prod. It also sets all the elements of d_flags to 0.</p>
<p>Template parameter <em>T</em> is the datatype of the matrix A and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_flags</td><td>The output flags array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_prod</td><td>The output products array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_A</td><td>The input matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_x</td><td>The input array x </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_indx</td><td>The input array of column indices for each element in A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numNZElts</td><td>The number of non-zero elements in matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga650782aef0e14c36782f5c24cd96a8dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void sparseMatrixVectorSetFlags </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_rowindx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numRows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Flags kernel. </p>
<p>This <b>global</b> device function takes an element from the vector d_rowindx, and sets the corresponding position in d_flags to 1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_flags</td><td>The output flags array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_rowindx</td><td>The starting index of each row in the "flattened" version of matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRows</td><td>The number of rows in matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9ed96c2a55daf3050462ef744a6afb89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void yGather </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_prod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_rowFindx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numRows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gather final y values kernel. </p>
<p>This <b>global</b> device function takes an element from the vector d_rowFindx, which for each row gives the index of the last element of that row, reads the corresponding position in d_prod and write it in d_y</p>
<p>Template parameter <em>T</em> is the datatype of the matrix A and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_y</td><td>The output result array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_prod</td><td>The input products array (which now contains sums for each row) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_rowFindx</td><td>The starting index of each row in the "flattened" version of matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRows</td><td>The number of rows in matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga70ad10920cae47887cda3b7f3b054663"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void alignedOffsets </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>numSpaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_stringVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>termC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>stringSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the number of spaces required for each string to align the string array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">numSpaces</td><td>Number of spaces required for each string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_address</td><td>Input addresses of each string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_stringVals</td><td>String array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">termC</td><td>Termination character for the strings </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of strings </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringSize</td><td>Number of characters in the string array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga594b6e4c562178da2f9371ba419e6ec0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void alignString </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>packedStrings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_stringVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>packedAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>stringArrayLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>termC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packs strings into unsigned ints to be sorted later. These packed strings will also be aligned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">packedStrings</td><td>Resulting packed strings. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_stringVals</td><td>Unpacked string array which we will pack </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">packedAddress</td><td>Resulting addresses for each string to the packedStrings array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Input addresses of unpacked strings </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of strings </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringArrayLength</td><td>Number of characters in the string array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">termC</td><td>Termination character for the strings </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaffe16a1f50800b5e68d28595dda134fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void createKeys </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>packedStrings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>packedAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create keys (first four characters stuffed in an uint) from the addresses to the strings, and the string array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys</td><td>Resulting keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packedStrings</td><td>Packed string array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packedAddress</td><td>Addresses which point to the string array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of strings </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga689cbede029512b4cdc4978943161594"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void unpackAddresses </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>packedAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>packedAddressRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>addressRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts addresses from packed (unaligned) form to unpacked and unaligned form Resulting aligned strings begin in our string array packed in an unsigned int and aligned such that each string begins at the start of a uint (divisible by 4) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packedAddress</td><td>Resulting packed addresses that have been sorted. All strings are aligned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packedAddressRef</td><td>Original array after packing (before sort). Used as a reference. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">address</td><td>Final output of sorted addresses in unpacked form. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addressRef</td><td>Reference array of original unpacked addresses. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of strings </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0b3a522a516d07de956b9322fd705f2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void blockWiseStringSort </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>stringVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>totalSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>stringSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>termC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does an initial blockSort based on the size of our partition (limited by shared memory size) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A_keys,A_address</td><td>This sort is in-place. A_keys and A_address store the key (first four characters) and addresses of our strings </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringVals</td><td>Global array of strings for tie breaks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockSize</td><td>size of each block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">totalSize</td><td>The total size of the array we are sorting </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringSize</td><td>The size of our string array (stringVals) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">termC</td><td>Termination character for the strings </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga88d04c464169fdfd0fab7ca254008282"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void simpleStringMerge </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_values_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>stringValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizePerPartition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stringSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>termC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges two independent sets. Each CUDA block works on two partitions of data without cooperating. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A_keys</td><td>First four characters (input) of our sets to merge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_values</td><td>Addresses of the strings (for tie breaks) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringValues</td><td>Global string array for tie breaks </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_keys_out,A_values_out</td><td>Keys and values array after merge step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizePerPartition</td><td>The size of each partition for this merge step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Global size of our array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step</td><td>Number of merges done so far </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringSize</td><td>global string length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">termC</td><td>Termination character for the strings </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4b72611f4d03803fbdb455537140fac6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void findMultiPartitions </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>stringValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>splitsPP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numPartitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>partitionSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>partitionBeginA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>partitionSizesA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>partitionBeginB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>partitionSizesB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stringSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>termC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For our multiMerge kernels we need to divide our partitions into smaller partitions. This kernel breaks up a set of partitions into splitsPP*numPartitions subpartitions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A_keys,A_address</td><td>First four characters (input), and addresses of our inputs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringValues</td><td>Global string array for tie breaks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splitsPP,numPartitions,partitionSize</td><td>Partition information for this routine (splitsPP=splits Per Partition) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitionBeginA,partitionSizesA</td><td>Partition starting points and sizes for each new subpartition in our original set in A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitionBeginB,partitionSizesB</td><td>Partition starting points and sizes for each new subpartition in our original set in B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size,stringSize</td><td>Number of elements in our set, and size of our global string array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">termC</td><td>Termination character for the strings </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3d49363709d861ae8ff4468595144f0d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void stringMergeMulti </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_values_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>stringValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subPartitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numBlocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>partitionBeginA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>partitionSizeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>partitionBeginB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>partitionSizeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>entirePartitionSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stringSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>termC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main merge kernel where multiple CUDA blocks cooperate to merge a partition(s) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A_keys,A_values</td><td>First four characters (input), and addresses of our inputs </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_keys_out,A_values_out</td><td>First four characters, and addresses for our outputs(ping-pong) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringValues</td><td>string array for tie breaks </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">subPartitions,numBlocks</td><td>Number of splits per partitions and number of partitions respectively </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitionBeginA,partitionSizeA</td><td>Where partitions begin and how large they are for Segment A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitionBeginB,partitionSizeB</td><td>Where partitions begin and how large they are for Segment B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entirePartitionSize</td><td>The maximum length of a partition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step</td><td>Number of merge cycles done </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of total strings being sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringSize</td><td>Length of string array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">termC</td><td>Termination character for the strings </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga41a45d3864bf92579aec2abcdf0cbe3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void crpcrKernel </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>systemSizeOriginal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iterations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hybrid CR-PCR Tridiagonal linear system solver (CRPCR) </p>
<p>This kernel solves a tridiagonal linear system using a hybrid CR-PCR algorithm. The solver first reduces the system size using cyclic reduction, then solves the intermediate system using parallel cyclic reduction to reduce shared memory bank conflicts and algorithmic steps, and finally switches back to cyclic reduction to solve all unknowns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_x</td><td>Solution vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_a</td><td>Lower diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_b</td><td>Main diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_c</td><td>Upper diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_d</td><td>Right hand side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemSizeOriginal</td><td>The size of each system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterations</td><td>The computed number of PCR iterations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8c8f5547a1f502329282cc95429740d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void vectorAddConstant </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>constant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a constant value to all values in the input d_vector. </p>
<p>Each thread adds two pairs of elements. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd>Test this function &ndash; it is currently not yet used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_vector</td><td>The array of elements to be modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constant</td><td>The constant value to be added to elements of <em>d_vector</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of elements in the d_vector to be modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baseIndex</td><td>An optional offset to the beginning of the elements in the input array to be processed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga24917914ea67043dbf8163f9e2add37f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void vectorAddUniform </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_uniforms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a uniform value to each data element of an array. </p>
<p>This function reads one value per CTA from <em>d_uniforms</em> into shared memory and adds that value to all values "owned" by the CTA in <em>d_vector</em>. Each thread adds two pairs of values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_vector</td><td>The d_vector whose values will have the uniform added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_uniforms</td><td>The array of uniform values (one per CTA) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in <em>d_vector</em> to process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockOffset</td><td>an optional offset to the beginning of this block's data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baseIndex</td><td>an optional offset to the beginning of the array within <em>d_vector</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1863374854d2c073002707ba6032fbd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Oper , int elementsPerThread, bool fullBlocks&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void vectorAddUniform4 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_uniforms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vectorRowPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>uniformRowPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a uniform value to each data element of an array (vec4 version) </p>
<p>This function reads one value per CTA from <em>d_uniforms</em> into shared memory and adds that value to all values "owned" by the CTA in <em>d_vector</em>. Each thread adds the uniform value to eight values in <em>d_vector</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_vector</td><td>The d_vector whose values will have the uniform added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_uniforms</td><td>The array of uniform values (one per CTA) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in <em>d_vector</em> to process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vectorRowPitch</td><td>For 2D arrays, the pitch (in elements) of the rows of <em>d_vector</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uniformRowPitch</td><td>For 2D arrays, the pitch (in elements) of the rows of <em>d_uniforms</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockOffset</td><td>an optional offset to the beginning of this block's data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baseIndex</td><td>an optional offset to the beginning of the array within <em>d_vector</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga09b902a5ab815491eb7cd6fa52a127d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void vectorAddVector </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_vectorA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_vectorB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds together two vectors. </p>
<p>Each thread adds two pairs of elements. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd>Test this function &ndash; it is currently not yet used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_vectorA</td><td>The left operand array and the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_vectorB</td><td>The right operand array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in the vectors to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baseIndex</td><td>An optional offset to the beginning of the elements in the input arrays to be processed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3918c5ba5af7670e6a7d3fbeb9bf575b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Oper , bool isLastBlockFull&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void vectorSegmentedAddUniform4 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_uniforms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_maxIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a uniform value to data elements of an array (vec4 version) </p>
<p>This function reads one value per CTA from <em>d_uniforms</em> into shared memory and adds that value to values "owned" by the CTA in <em>d_vector</em>. The uniform value is added to only those values "owned" by the CTA which have an index less than d_maxIndex. If d_maxIndex for that CTA is UINT_MAX it adds the uniform to all values "owned" by the CTA. Each thread adds the uniform value to eight values in <em>d_vector</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_vector</td><td>The d_vector whose values will have the uniform added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_uniforms</td><td>The array of uniform values (one per CTA) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_maxIndices</td><td>The array of maximum indices (one per CTA). This is index upto which the uniform would be added. If this is UINT_MAX the uniform is added to all elements of the CTA. This index is 1-based. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in <em>d_vector</em> to process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockOffset</td><td>an optional offset to the beginning of this block's data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baseIndex</td><td>an optional offset to the beginning of the array within <em>d_vector</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2f54ac578b08ad752c5771bce9115084"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Oper , bool isLastBlockFull&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void vectorSegmentedAddUniformToRight4 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_uniforms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_minIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a uniform value to data elements of an array (vec4 version) </p>
<p>This function reads one value per CTA from <em>d_uniforms</em> into shared memory and adds that value to values "owned" by the CTA in <em>d_vector</em>. The uniform value is added to only those values "owned" by the CTA which have an index greater than d_minIndex. If d_minIndex for that CTA is 0 it adds the uniform to all values "owned" by the CTA. Each thread adds the uniform value to eight values in <em>d_vector</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_vector</td><td>The d_vector whose values will have the uniform added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_uniforms</td><td>The array of uniform values (one per CTA) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_minIndices</td><td>The array of minimum indices (one per CTA). The uniform is added to the right of this index (that is, to every index that is greater than this index). If this is 0, the uniform is added to all elements of the CTA. This index is 1-based to prevent overloading of what 0 means. In our case it means absence of a flag. But if the first element of a CTA has flag the index will also be 0. Hence we use 1-based indices so the index is 1 in the latter case. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in <em>d_vector</em> to process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockOffset</td><td>an optional offset to the beginning of this block's data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baseIndex</td><td>an optional offset to the beginning of the array within <em>d_vector</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Nov 30 2016 15:29:13 for CUDPP by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
